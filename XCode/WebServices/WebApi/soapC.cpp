/*
 $Author: cattaneo $
 $Date: 2011-05-14 18:37:51 +0200(Sab, 14 Mag 2011) $
 $Revision: 11 $
 */

/* soapC.cpp
   Generated by gSOAP 2.8.2 from WebApi.h
   Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL OR Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.2 2011-04-26 11:09:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__Giustificativo:
		return soap_in_ns1__Giustificativo(soap, NULL, NULL, "ns1:Giustificativo");
	case SOAP_TYPE_ns1__Flusso:
		return soap_in_ns1__Flusso(soap, NULL, NULL, "ns1:Flusso");
	case SOAP_TYPE_ns1__Procedimento:
		return soap_in_ns1__Procedimento(soap, NULL, NULL, "ns1:Procedimento");
	case SOAP_TYPE_ns1__ArrayOfStepCompetenza:
		return soap_in_ns1__ArrayOfStepCompetenza(soap, NULL, NULL, "ns1:ArrayOfStepCompetenza");
	case SOAP_TYPE_ns1__StepCompetenza:
		return soap_in_ns1__StepCompetenza(soap, NULL, NULL, "ns1:StepCompetenza");
	case SOAP_TYPE_ns1__ArrayOfFunzione:
		return soap_in_ns1__ArrayOfFunzione(soap, NULL, NULL, "ns1:ArrayOfFunzione");
	case SOAP_TYPE_ns1__Funzione:
		return soap_in_ns1__Funzione(soap, NULL, NULL, "ns1:Funzione");
	case SOAP_TYPE_ns1__ArrayOfAttributo:
		return soap_in_ns1__ArrayOfAttributo(soap, NULL, NULL, "ns1:ArrayOfAttributo");
	case SOAP_TYPE_ns1__Attributo:
		return soap_in_ns1__Attributo(soap, NULL, NULL, "ns1:Attributo");
	case SOAP_TYPE_ns1__Esito:
		return soap_in_ns1__Esito(soap, NULL, NULL, "ns1:Esito");
	case SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring:
		return soap_in_ns1__ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "ns1:ArrayOf_xsd_string");
	case SOAP_TYPE_ns1__ArrayOfStep:
		return soap_in_ns1__ArrayOfStep(soap, NULL, NULL, "ns1:ArrayOfStep");
	case SOAP_TYPE_ns1__Step:
		return soap_in_ns1__Step(soap, NULL, NULL, "ns1:Step");
	case SOAP_TYPE_ns1__Stato:
		return soap_in_ns1__Stato(soap, NULL, NULL, "ns1:Stato");
	case SOAP_TYPE_ns1__ArrayOfNota:
		return soap_in_ns1__ArrayOfNota(soap, NULL, NULL, "ns1:ArrayOfNota");
	case SOAP_TYPE_ns1__Nota:
		return soap_in_ns1__Nota(soap, NULL, NULL, "ns1:Nota");
	case SOAP_TYPE_ns1__MetaDato:
		return soap_in_ns1__MetaDato(soap, NULL, NULL, "ns1:MetaDato");
	case SOAP_TYPE_ns1__EccezioneSistema:
		return soap_in_ns1__EccezioneSistema(soap, NULL, NULL, "ns1:EccezioneSistema");
	case SOAP_TYPE_ns1__EccezioneAutenticazione:
		return soap_in_ns1__EccezioneAutenticazione(soap, NULL, NULL, "ns1:EccezioneAutenticazione");
	case SOAP_TYPE_PointerTo_ns1__getGiustificativiResponse:
		return soap_in_PointerTo_ns1__getGiustificativiResponse(soap, NULL, NULL, "ns1:getGiustificativiResponse");
	case SOAP_TYPE_PointerTo_ns1__getGiustificativi:
		return soap_in_PointerTo_ns1__getGiustificativi(soap, NULL, NULL, "ns1:getGiustificativi");
	case SOAP_TYPE_PointerTo_ns1__getFlussiResponse:
		return soap_in_PointerTo_ns1__getFlussiResponse(soap, NULL, NULL, "ns1:getFlussiResponse");
	case SOAP_TYPE_PointerTo_ns1__getFlussi:
		return soap_in_PointerTo_ns1__getFlussi(soap, NULL, NULL, "ns1:getFlussi");
	case SOAP_TYPE_PointerTo_ns1__avanzaProcedimentoResponse:
		return soap_in_PointerTo_ns1__avanzaProcedimentoResponse(soap, NULL, NULL, "ns1:avanzaProcedimentoResponse");
	case SOAP_TYPE_PointerTo_ns1__avanzaProcedimento:
		return soap_in_PointerTo_ns1__avanzaProcedimento(soap, NULL, NULL, "ns1:avanzaProcedimento");
	case SOAP_TYPE_PointerTo_ns1__getProcedimentoResponse:
		return soap_in_PointerTo_ns1__getProcedimentoResponse(soap, NULL, NULL, "ns1:getProcedimentoResponse");
	case SOAP_TYPE_PointerTo_ns1__getProcedimento:
		return soap_in_PointerTo_ns1__getProcedimento(soap, NULL, NULL, "ns1:getProcedimento");
	case SOAP_TYPE_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse:
		return soap_in_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(soap, NULL, NULL, "ns1:aggiungiDocumentoAlProcedimentoResponse");
	case SOAP_TYPE_PointerTo_ns1__aggiungiDocumentoAlProcedimento:
		return soap_in_PointerTo_ns1__aggiungiDocumentoAlProcedimento(soap, NULL, NULL, "ns1:aggiungiDocumentoAlProcedimento");
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoWideResponse:
		return soap_in_PointerTo_ns1__attivaProcedimentoWideResponse(soap, NULL, NULL, "ns1:attivaProcedimentoWideResponse");
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoWide:
		return soap_in_PointerTo_ns1__attivaProcedimentoWide(soap, NULL, NULL, "ns1:attivaProcedimentoWide");
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoResponse:
		return soap_in_PointerTo_ns1__attivaProcedimentoResponse(soap, NULL, NULL, "ns1:attivaProcedimentoResponse");
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimento:
		return soap_in_PointerTo_ns1__attivaProcedimento(soap, NULL, NULL, "ns1:attivaProcedimento");
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		return soap_in_PointerTo_ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_PointerTo_ns1__login:
		return soap_in_PointerTo_ns1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_PointerTo_ns1__getTokenResponse:
		return soap_in_PointerTo_ns1__getTokenResponse(soap, NULL, NULL, "ns1:getTokenResponse");
	case SOAP_TYPE_PointerTo_ns1__getToken:
		return soap_in_PointerTo_ns1__getToken(soap, NULL, NULL, "ns1:getToken");
	case SOAP_TYPE_PointerTons1__EccezioneSistema:
		return soap_in_PointerTons1__EccezioneSistema(soap, NULL, NULL, "ns1:EccezioneSistema");
	case SOAP_TYPE_PointerTons1__EccezioneAutenticazione:
		return soap_in_PointerTons1__EccezioneAutenticazione(soap, NULL, NULL, "ns1:EccezioneAutenticazione");
	case SOAP_TYPE_PointerTons1__ArrayOfFunzione:
		return soap_in_PointerTons1__ArrayOfFunzione(soap, NULL, NULL, "ns1:ArrayOfFunzione");
	case SOAP_TYPE_PointerTons1__Esito:
		return soap_in_PointerTons1__Esito(soap, NULL, NULL, "ns1:Esito");
	case SOAP_TYPE_PointerToPointerTons1__Giustificativo:
		return soap_in_PointerToPointerTons1__Giustificativo(soap, NULL, NULL, "ns1:Giustificativo");
	case SOAP_TYPE_PointerTons1__Giustificativo:
		return soap_in_PointerTons1__Giustificativo(soap, NULL, NULL, "ns1:Giustificativo");
	case SOAP_TYPE_PointerToPointerTons1__Flusso:
		return soap_in_PointerToPointerTons1__Flusso(soap, NULL, NULL, "ns1:Flusso");
	case SOAP_TYPE_PointerTons1__Flusso:
		return soap_in_PointerTons1__Flusso(soap, NULL, NULL, "ns1:Flusso");
	case SOAP_TYPE_PointerTons1__Procedimento:
		return soap_in_PointerTons1__Procedimento(soap, NULL, NULL, "ns1:Procedimento");
	case SOAP_TYPE_PointerToPointerTons1__MetaDato:
		return soap_in_PointerToPointerTons1__MetaDato(soap, NULL, NULL, "ns1:MetaDato");
	case SOAP_TYPE_PointerTons1__MetaDato:
		return soap_in_PointerTons1__MetaDato(soap, NULL, NULL, "ns1:MetaDato");
	case SOAP_TYPE_PointerTons1__ArrayOfStepCompetenza:
		return soap_in_PointerTons1__ArrayOfStepCompetenza(soap, NULL, NULL, "ns1:ArrayOfStepCompetenza");
	case SOAP_TYPE_PointerTons1__ArrayOfStep:
		return soap_in_PointerTons1__ArrayOfStep(soap, NULL, NULL, "ns1:ArrayOfStep");
	case SOAP_TYPE_PointerTons1__Stato:
		return soap_in_PointerTons1__Stato(soap, NULL, NULL, "ns1:Stato");
	case SOAP_TYPE_PointerTons1__ArrayOfNota:
		return soap_in_PointerTons1__ArrayOfNota(soap, NULL, NULL, "ns1:ArrayOfNota");
	case SOAP_TYPE_PointerToPointerTons1__StepCompetenza:
		return soap_in_PointerToPointerTons1__StepCompetenza(soap, NULL, NULL, "ns1:StepCompetenza");
	case SOAP_TYPE_PointerTons1__StepCompetenza:
		return soap_in_PointerTons1__StepCompetenza(soap, NULL, NULL, "ns1:StepCompetenza");
	case SOAP_TYPE_PointerToPointerTons1__Funzione:
		return soap_in_PointerToPointerTons1__Funzione(soap, NULL, NULL, "ns1:Funzione");
	case SOAP_TYPE_PointerTons1__Funzione:
		return soap_in_PointerTons1__Funzione(soap, NULL, NULL, "ns1:Funzione");
	case SOAP_TYPE_PointerTons1__ArrayOfAttributo:
		return soap_in_PointerTons1__ArrayOfAttributo(soap, NULL, NULL, "ns1:ArrayOfAttributo");
	case SOAP_TYPE_PointerToPointerTons1__Attributo:
		return soap_in_PointerToPointerTons1__Attributo(soap, NULL, NULL, "ns1:Attributo");
	case SOAP_TYPE_PointerTons1__Attributo:
		return soap_in_PointerTons1__Attributo(soap, NULL, NULL, "ns1:Attributo");
	case SOAP_TYPE_PointerTons1__ArrayOf_USCORExsd_USCOREstring:
		return soap_in_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "ns1:ArrayOf_xsd_string");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__Step:
		return soap_in_PointerToPointerTons1__Step(soap, NULL, NULL, "ns1:Step");
	case SOAP_TYPE_PointerTons1__Step:
		return soap_in_PointerTons1__Step(soap, NULL, NULL, "ns1:Step");
	case SOAP_TYPE_PointerToPointerTons1__Nota:
		return soap_in_PointerToPointerTons1__Nota(soap, NULL, NULL, "ns1:Nota");
	case SOAP_TYPE_PointerTons1__Nota:
		return soap_in_PointerTons1__Nota(soap, NULL, NULL, "ns1:Nota");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:Giustificativo"))
		{	*type = SOAP_TYPE_ns1__Giustificativo;
			return soap_in_ns1__Giustificativo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Flusso"))
		{	*type = SOAP_TYPE_ns1__Flusso;
			return soap_in_ns1__Flusso(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Procedimento"))
		{	*type = SOAP_TYPE_ns1__Procedimento;
			return soap_in_ns1__Procedimento(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfStepCompetenza"))
		{	*type = SOAP_TYPE_ns1__ArrayOfStepCompetenza;
			return soap_in_ns1__ArrayOfStepCompetenza(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StepCompetenza"))
		{	*type = SOAP_TYPE_ns1__StepCompetenza;
			return soap_in_ns1__StepCompetenza(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfFunzione"))
		{	*type = SOAP_TYPE_ns1__ArrayOfFunzione;
			return soap_in_ns1__ArrayOfFunzione(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Funzione"))
		{	*type = SOAP_TYPE_ns1__Funzione;
			return soap_in_ns1__Funzione(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfAttributo"))
		{	*type = SOAP_TYPE_ns1__ArrayOfAttributo;
			return soap_in_ns1__ArrayOfAttributo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Attributo"))
		{	*type = SOAP_TYPE_ns1__Attributo;
			return soap_in_ns1__Attributo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Esito"))
		{	*type = SOAP_TYPE_ns1__Esito;
			return soap_in_ns1__Esito(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOf_xsd_string"))
		{	*type = SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring;
			return soap_in_ns1__ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfStep"))
		{	*type = SOAP_TYPE_ns1__ArrayOfStep;
			return soap_in_ns1__ArrayOfStep(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Step"))
		{	*type = SOAP_TYPE_ns1__Step;
			return soap_in_ns1__Step(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Stato"))
		{	*type = SOAP_TYPE_ns1__Stato;
			return soap_in_ns1__Stato(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfNota"))
		{	*type = SOAP_TYPE_ns1__ArrayOfNota;
			return soap_in_ns1__ArrayOfNota(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Nota"))
		{	*type = SOAP_TYPE_ns1__Nota;
			return soap_in_ns1__Nota(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MetaDato"))
		{	*type = SOAP_TYPE_ns1__MetaDato;
			return soap_in_ns1__MetaDato(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EccezioneSistema"))
		{	*type = SOAP_TYPE_ns1__EccezioneSistema;
			return soap_in_ns1__EccezioneSistema(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EccezioneAutenticazione"))
		{	*type = SOAP_TYPE_ns1__EccezioneAutenticazione;
			return soap_in_ns1__EccezioneAutenticazione(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:getGiustificativiResponse"))
		{	*type = SOAP_TYPE__ns1__getGiustificativiResponse;
			return soap_in__ns1__getGiustificativiResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGiustificativi"))
		{	*type = SOAP_TYPE__ns1__getGiustificativi;
			return soap_in__ns1__getGiustificativi(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFlussiResponse"))
		{	*type = SOAP_TYPE__ns1__getFlussiResponse;
			return soap_in__ns1__getFlussiResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFlussi"))
		{	*type = SOAP_TYPE__ns1__getFlussi;
			return soap_in__ns1__getFlussi(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:avanzaProcedimentoResponse"))
		{	*type = SOAP_TYPE__ns1__avanzaProcedimentoResponse;
			return soap_in__ns1__avanzaProcedimentoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:avanzaProcedimento"))
		{	*type = SOAP_TYPE__ns1__avanzaProcedimento;
			return soap_in__ns1__avanzaProcedimento(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcedimentoResponse"))
		{	*type = SOAP_TYPE__ns1__getProcedimentoResponse;
			return soap_in__ns1__getProcedimentoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcedimento"))
		{	*type = SOAP_TYPE__ns1__getProcedimento;
			return soap_in__ns1__getProcedimento(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:aggiungiDocumentoAlProcedimentoResponse"))
		{	*type = SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse;
			return soap_in__ns1__aggiungiDocumentoAlProcedimentoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:aggiungiDocumentoAlProcedimento"))
		{	*type = SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento;
			return soap_in__ns1__aggiungiDocumentoAlProcedimento(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:attivaProcedimentoWideResponse"))
		{	*type = SOAP_TYPE__ns1__attivaProcedimentoWideResponse;
			return soap_in__ns1__attivaProcedimentoWideResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:attivaProcedimentoWide"))
		{	*type = SOAP_TYPE__ns1__attivaProcedimentoWide;
			return soap_in__ns1__attivaProcedimentoWide(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:attivaProcedimentoResponse"))
		{	*type = SOAP_TYPE__ns1__attivaProcedimentoResponse;
			return soap_in__ns1__attivaProcedimentoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:attivaProcedimento"))
		{	*type = SOAP_TYPE__ns1__attivaProcedimento;
			return soap_in__ns1__attivaProcedimento(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE__ns1__loginResponse;
			return soap_in__ns1__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:login"))
		{	*type = SOAP_TYPE__ns1__login;
			return soap_in__ns1__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTokenResponse"))
		{	*type = SOAP_TYPE__ns1__getTokenResponse;
			return soap_in__ns1__getTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getToken"))
		{	*type = SOAP_TYPE__ns1__getToken;
			return soap_in__ns1__getToken(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__getGiustificativiResponse:
		return ((_ns1__getGiustificativiResponse *)ptr)->soap_out(soap, "ns1:getGiustificativiResponse", id, NULL);
	case SOAP_TYPE__ns1__getGiustificativi:
		return ((_ns1__getGiustificativi *)ptr)->soap_out(soap, "ns1:getGiustificativi", id, NULL);
	case SOAP_TYPE__ns1__getFlussiResponse:
		return ((_ns1__getFlussiResponse *)ptr)->soap_out(soap, "ns1:getFlussiResponse", id, NULL);
	case SOAP_TYPE__ns1__getFlussi:
		return ((_ns1__getFlussi *)ptr)->soap_out(soap, "ns1:getFlussi", id, NULL);
	case SOAP_TYPE__ns1__avanzaProcedimentoResponse:
		return ((_ns1__avanzaProcedimentoResponse *)ptr)->soap_out(soap, "ns1:avanzaProcedimentoResponse", id, NULL);
	case SOAP_TYPE__ns1__avanzaProcedimento:
		return ((_ns1__avanzaProcedimento *)ptr)->soap_out(soap, "ns1:avanzaProcedimento", id, NULL);
	case SOAP_TYPE__ns1__getProcedimentoResponse:
		return ((_ns1__getProcedimentoResponse *)ptr)->soap_out(soap, "ns1:getProcedimentoResponse", id, NULL);
	case SOAP_TYPE__ns1__getProcedimento:
		return ((_ns1__getProcedimento *)ptr)->soap_out(soap, "ns1:getProcedimento", id, NULL);
	case SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse:
		return ((_ns1__aggiungiDocumentoAlProcedimentoResponse *)ptr)->soap_out(soap, "ns1:aggiungiDocumentoAlProcedimentoResponse", id, NULL);
	case SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento:
		return ((_ns1__aggiungiDocumentoAlProcedimento *)ptr)->soap_out(soap, "ns1:aggiungiDocumentoAlProcedimento", id, NULL);
	case SOAP_TYPE__ns1__attivaProcedimentoWideResponse:
		return ((_ns1__attivaProcedimentoWideResponse *)ptr)->soap_out(soap, "ns1:attivaProcedimentoWideResponse", id, NULL);
	case SOAP_TYPE__ns1__attivaProcedimentoWide:
		return ((_ns1__attivaProcedimentoWide *)ptr)->soap_out(soap, "ns1:attivaProcedimentoWide", id, NULL);
	case SOAP_TYPE__ns1__attivaProcedimentoResponse:
		return ((_ns1__attivaProcedimentoResponse *)ptr)->soap_out(soap, "ns1:attivaProcedimentoResponse", id, NULL);
	case SOAP_TYPE__ns1__attivaProcedimento:
		return ((_ns1__attivaProcedimento *)ptr)->soap_out(soap, "ns1:attivaProcedimento", id, NULL);
	case SOAP_TYPE__ns1__loginResponse:
		return ((_ns1__loginResponse *)ptr)->soap_out(soap, "ns1:loginResponse", id, NULL);
	case SOAP_TYPE__ns1__login:
		return ((_ns1__login *)ptr)->soap_out(soap, "ns1:login", id, NULL);
	case SOAP_TYPE__ns1__getTokenResponse:
		return ((_ns1__getTokenResponse *)ptr)->soap_out(soap, "ns1:getTokenResponse", id, NULL);
	case SOAP_TYPE__ns1__getToken:
		return ((_ns1__getToken *)ptr)->soap_out(soap, "ns1:getToken", id, NULL);
	case SOAP_TYPE_ns1__Giustificativo:
		return ((ns1__Giustificativo *)ptr)->soap_out(soap, tag, id, "ns1:Giustificativo");
	case SOAP_TYPE_ns1__Flusso:
		return ((ns1__Flusso *)ptr)->soap_out(soap, tag, id, "ns1:Flusso");
	case SOAP_TYPE_ns1__Procedimento:
		return ((ns1__Procedimento *)ptr)->soap_out(soap, tag, id, "ns1:Procedimento");
	case SOAP_TYPE_ns1__ArrayOfStepCompetenza:
		return ((ns1__ArrayOfStepCompetenza *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfStepCompetenza");
	case SOAP_TYPE_ns1__StepCompetenza:
		return ((ns1__StepCompetenza *)ptr)->soap_out(soap, tag, id, "ns1:StepCompetenza");
	case SOAP_TYPE_ns1__ArrayOfFunzione:
		return ((ns1__ArrayOfFunzione *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfFunzione");
	case SOAP_TYPE_ns1__Funzione:
		return ((ns1__Funzione *)ptr)->soap_out(soap, tag, id, "ns1:Funzione");
	case SOAP_TYPE_ns1__ArrayOfAttributo:
		return ((ns1__ArrayOfAttributo *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfAttributo");
	case SOAP_TYPE_ns1__Attributo:
		return ((ns1__Attributo *)ptr)->soap_out(soap, tag, id, "ns1:Attributo");
	case SOAP_TYPE_ns1__Esito:
		return ((ns1__Esito *)ptr)->soap_out(soap, tag, id, "ns1:Esito");
	case SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring:
		return ((ns1__ArrayOf_USCORExsd_USCOREstring *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOf_xsd_string");
	case SOAP_TYPE_ns1__ArrayOfStep:
		return ((ns1__ArrayOfStep *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfStep");
	case SOAP_TYPE_ns1__Step:
		return ((ns1__Step *)ptr)->soap_out(soap, tag, id, "ns1:Step");
	case SOAP_TYPE_ns1__Stato:
		return ((ns1__Stato *)ptr)->soap_out(soap, tag, id, "ns1:Stato");
	case SOAP_TYPE_ns1__ArrayOfNota:
		return ((ns1__ArrayOfNota *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfNota");
	case SOAP_TYPE_ns1__Nota:
		return ((ns1__Nota *)ptr)->soap_out(soap, tag, id, "ns1:Nota");
	case SOAP_TYPE_ns1__MetaDato:
		return ((ns1__MetaDato *)ptr)->soap_out(soap, tag, id, "ns1:MetaDato");
	case SOAP_TYPE_ns1__EccezioneSistema:
		return ((ns1__EccezioneSistema *)ptr)->soap_out(soap, tag, id, "ns1:EccezioneSistema");
	case SOAP_TYPE_ns1__EccezioneAutenticazione:
		return ((ns1__EccezioneAutenticazione *)ptr)->soap_out(soap, tag, id, "ns1:EccezioneAutenticazione");
	case SOAP_TYPE_PointerTo_ns1__getGiustificativiResponse:
		return soap_out_PointerTo_ns1__getGiustificativiResponse(soap, tag, id, (_ns1__getGiustificativiResponse *const*)ptr, "ns1:getGiustificativiResponse");
	case SOAP_TYPE_PointerTo_ns1__getGiustificativi:
		return soap_out_PointerTo_ns1__getGiustificativi(soap, tag, id, (_ns1__getGiustificativi *const*)ptr, "ns1:getGiustificativi");
	case SOAP_TYPE_PointerTo_ns1__getFlussiResponse:
		return soap_out_PointerTo_ns1__getFlussiResponse(soap, tag, id, (_ns1__getFlussiResponse *const*)ptr, "ns1:getFlussiResponse");
	case SOAP_TYPE_PointerTo_ns1__getFlussi:
		return soap_out_PointerTo_ns1__getFlussi(soap, tag, id, (_ns1__getFlussi *const*)ptr, "ns1:getFlussi");
	case SOAP_TYPE_PointerTo_ns1__avanzaProcedimentoResponse:
		return soap_out_PointerTo_ns1__avanzaProcedimentoResponse(soap, tag, id, (_ns1__avanzaProcedimentoResponse *const*)ptr, "ns1:avanzaProcedimentoResponse");
	case SOAP_TYPE_PointerTo_ns1__avanzaProcedimento:
		return soap_out_PointerTo_ns1__avanzaProcedimento(soap, tag, id, (_ns1__avanzaProcedimento *const*)ptr, "ns1:avanzaProcedimento");
	case SOAP_TYPE_PointerTo_ns1__getProcedimentoResponse:
		return soap_out_PointerTo_ns1__getProcedimentoResponse(soap, tag, id, (_ns1__getProcedimentoResponse *const*)ptr, "ns1:getProcedimentoResponse");
	case SOAP_TYPE_PointerTo_ns1__getProcedimento:
		return soap_out_PointerTo_ns1__getProcedimento(soap, tag, id, (_ns1__getProcedimento *const*)ptr, "ns1:getProcedimento");
	case SOAP_TYPE_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse:
		return soap_out_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(soap, tag, id, (_ns1__aggiungiDocumentoAlProcedimentoResponse *const*)ptr, "ns1:aggiungiDocumentoAlProcedimentoResponse");
	case SOAP_TYPE_PointerTo_ns1__aggiungiDocumentoAlProcedimento:
		return soap_out_PointerTo_ns1__aggiungiDocumentoAlProcedimento(soap, tag, id, (_ns1__aggiungiDocumentoAlProcedimento *const*)ptr, "ns1:aggiungiDocumentoAlProcedimento");
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoWideResponse:
		return soap_out_PointerTo_ns1__attivaProcedimentoWideResponse(soap, tag, id, (_ns1__attivaProcedimentoWideResponse *const*)ptr, "ns1:attivaProcedimentoWideResponse");
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoWide:
		return soap_out_PointerTo_ns1__attivaProcedimentoWide(soap, tag, id, (_ns1__attivaProcedimentoWide *const*)ptr, "ns1:attivaProcedimentoWide");
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoResponse:
		return soap_out_PointerTo_ns1__attivaProcedimentoResponse(soap, tag, id, (_ns1__attivaProcedimentoResponse *const*)ptr, "ns1:attivaProcedimentoResponse");
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimento:
		return soap_out_PointerTo_ns1__attivaProcedimento(soap, tag, id, (_ns1__attivaProcedimento *const*)ptr, "ns1:attivaProcedimento");
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		return soap_out_PointerTo_ns1__loginResponse(soap, tag, id, (_ns1__loginResponse *const*)ptr, "ns1:loginResponse");
	case SOAP_TYPE_PointerTo_ns1__login:
		return soap_out_PointerTo_ns1__login(soap, tag, id, (_ns1__login *const*)ptr, "ns1:login");
	case SOAP_TYPE_PointerTo_ns1__getTokenResponse:
		return soap_out_PointerTo_ns1__getTokenResponse(soap, tag, id, (_ns1__getTokenResponse *const*)ptr, "ns1:getTokenResponse");
	case SOAP_TYPE_PointerTo_ns1__getToken:
		return soap_out_PointerTo_ns1__getToken(soap, tag, id, (_ns1__getToken *const*)ptr, "ns1:getToken");
	case SOAP_TYPE_PointerTons1__EccezioneSistema:
		return soap_out_PointerTons1__EccezioneSistema(soap, tag, id, (ns1__EccezioneSistema *const*)ptr, "ns1:EccezioneSistema");
	case SOAP_TYPE_PointerTons1__EccezioneAutenticazione:
		return soap_out_PointerTons1__EccezioneAutenticazione(soap, tag, id, (ns1__EccezioneAutenticazione *const*)ptr, "ns1:EccezioneAutenticazione");
	case SOAP_TYPE_PointerTons1__ArrayOfFunzione:
		return soap_out_PointerTons1__ArrayOfFunzione(soap, tag, id, (ns1__ArrayOfFunzione *const*)ptr, "ns1:ArrayOfFunzione");
	case SOAP_TYPE_PointerTons1__Esito:
		return soap_out_PointerTons1__Esito(soap, tag, id, (ns1__Esito *const*)ptr, "ns1:Esito");
	case SOAP_TYPE_PointerToPointerTons1__Giustificativo:
		return soap_out_PointerToPointerTons1__Giustificativo(soap, tag, id, (ns1__Giustificativo **const*)ptr, "ns1:Giustificativo");
	case SOAP_TYPE_PointerTons1__Giustificativo:
		return soap_out_PointerTons1__Giustificativo(soap, tag, id, (ns1__Giustificativo *const*)ptr, "ns1:Giustificativo");
	case SOAP_TYPE_PointerToPointerTons1__Flusso:
		return soap_out_PointerToPointerTons1__Flusso(soap, tag, id, (ns1__Flusso **const*)ptr, "ns1:Flusso");
	case SOAP_TYPE_PointerTons1__Flusso:
		return soap_out_PointerTons1__Flusso(soap, tag, id, (ns1__Flusso *const*)ptr, "ns1:Flusso");
	case SOAP_TYPE_PointerTons1__Procedimento:
		return soap_out_PointerTons1__Procedimento(soap, tag, id, (ns1__Procedimento *const*)ptr, "ns1:Procedimento");
	case SOAP_TYPE_PointerToPointerTons1__MetaDato:
		return soap_out_PointerToPointerTons1__MetaDato(soap, tag, id, (ns1__MetaDato **const*)ptr, "ns1:MetaDato");
	case SOAP_TYPE_PointerTons1__MetaDato:
		return soap_out_PointerTons1__MetaDato(soap, tag, id, (ns1__MetaDato *const*)ptr, "ns1:MetaDato");
	case SOAP_TYPE_PointerTons1__ArrayOfStepCompetenza:
		return soap_out_PointerTons1__ArrayOfStepCompetenza(soap, tag, id, (ns1__ArrayOfStepCompetenza *const*)ptr, "ns1:ArrayOfStepCompetenza");
	case SOAP_TYPE_PointerTons1__ArrayOfStep:
		return soap_out_PointerTons1__ArrayOfStep(soap, tag, id, (ns1__ArrayOfStep *const*)ptr, "ns1:ArrayOfStep");
	case SOAP_TYPE_PointerTons1__Stato:
		return soap_out_PointerTons1__Stato(soap, tag, id, (ns1__Stato *const*)ptr, "ns1:Stato");
	case SOAP_TYPE_PointerTons1__ArrayOfNota:
		return soap_out_PointerTons1__ArrayOfNota(soap, tag, id, (ns1__ArrayOfNota *const*)ptr, "ns1:ArrayOfNota");
	case SOAP_TYPE_PointerToPointerTons1__StepCompetenza:
		return soap_out_PointerToPointerTons1__StepCompetenza(soap, tag, id, (ns1__StepCompetenza **const*)ptr, "ns1:StepCompetenza");
	case SOAP_TYPE_PointerTons1__StepCompetenza:
		return soap_out_PointerTons1__StepCompetenza(soap, tag, id, (ns1__StepCompetenza *const*)ptr, "ns1:StepCompetenza");
	case SOAP_TYPE_PointerToPointerTons1__Funzione:
		return soap_out_PointerToPointerTons1__Funzione(soap, tag, id, (ns1__Funzione **const*)ptr, "ns1:Funzione");
	case SOAP_TYPE_PointerTons1__Funzione:
		return soap_out_PointerTons1__Funzione(soap, tag, id, (ns1__Funzione *const*)ptr, "ns1:Funzione");
	case SOAP_TYPE_PointerTons1__ArrayOfAttributo:
		return soap_out_PointerTons1__ArrayOfAttributo(soap, tag, id, (ns1__ArrayOfAttributo *const*)ptr, "ns1:ArrayOfAttributo");
	case SOAP_TYPE_PointerToPointerTons1__Attributo:
		return soap_out_PointerToPointerTons1__Attributo(soap, tag, id, (ns1__Attributo **const*)ptr, "ns1:Attributo");
	case SOAP_TYPE_PointerTons1__Attributo:
		return soap_out_PointerTons1__Attributo(soap, tag, id, (ns1__Attributo *const*)ptr, "ns1:Attributo");
	case SOAP_TYPE_PointerTons1__ArrayOf_USCORExsd_USCOREstring:
		return soap_out_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, tag, id, (ns1__ArrayOf_USCORExsd_USCOREstring *const*)ptr, "ns1:ArrayOf_xsd_string");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__Step:
		return soap_out_PointerToPointerTons1__Step(soap, tag, id, (ns1__Step **const*)ptr, "ns1:Step");
	case SOAP_TYPE_PointerTons1__Step:
		return soap_out_PointerTons1__Step(soap, tag, id, (ns1__Step *const*)ptr, "ns1:Step");
	case SOAP_TYPE_PointerToPointerTons1__Nota:
		return soap_out_PointerToPointerTons1__Nota(soap, tag, id, (ns1__Nota **const*)ptr, "ns1:Nota");
	case SOAP_TYPE_PointerTons1__Nota:
		return soap_out_PointerTons1__Nota(soap, tag, id, (ns1__Nota *const*)ptr, "ns1:Nota");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__getGiustificativiResponse:
		((_ns1__getGiustificativiResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getGiustificativi:
		((_ns1__getGiustificativi *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getFlussiResponse:
		((_ns1__getFlussiResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getFlussi:
		((_ns1__getFlussi *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__avanzaProcedimentoResponse:
		((_ns1__avanzaProcedimentoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__avanzaProcedimento:
		((_ns1__avanzaProcedimento *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getProcedimentoResponse:
		((_ns1__getProcedimentoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getProcedimento:
		((_ns1__getProcedimento *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse:
		((_ns1__aggiungiDocumentoAlProcedimentoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento:
		((_ns1__aggiungiDocumentoAlProcedimento *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__attivaProcedimentoWideResponse:
		((_ns1__attivaProcedimentoWideResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__attivaProcedimentoWide:
		((_ns1__attivaProcedimentoWide *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__attivaProcedimentoResponse:
		((_ns1__attivaProcedimentoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__attivaProcedimento:
		((_ns1__attivaProcedimento *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loginResponse:
		((_ns1__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__login:
		((_ns1__login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getTokenResponse:
		((_ns1__getTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getToken:
		((_ns1__getToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Giustificativo:
		((ns1__Giustificativo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Flusso:
		((ns1__Flusso *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Procedimento:
		((ns1__Procedimento *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfStepCompetenza:
		((ns1__ArrayOfStepCompetenza *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StepCompetenza:
		((ns1__StepCompetenza *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfFunzione:
		((ns1__ArrayOfFunzione *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Funzione:
		((ns1__Funzione *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfAttributo:
		((ns1__ArrayOfAttributo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Attributo:
		((ns1__Attributo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Esito:
		((ns1__Esito *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring:
		((ns1__ArrayOf_USCORExsd_USCOREstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfStep:
		((ns1__ArrayOfStep *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Step:
		((ns1__Step *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Stato:
		((ns1__Stato *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfNota:
		((ns1__ArrayOfNota *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Nota:
		((ns1__Nota *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MetaDato:
		((ns1__MetaDato *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EccezioneSistema:
		((ns1__EccezioneSistema *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EccezioneAutenticazione:
		((ns1__EccezioneAutenticazione *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getGiustificativi:
		soap_serialize___ns1__getGiustificativi(soap, (const struct __ns1__getGiustificativi *)ptr);
		break;
	case SOAP_TYPE___ns1__getFlussi:
		soap_serialize___ns1__getFlussi(soap, (const struct __ns1__getFlussi *)ptr);
		break;
	case SOAP_TYPE___ns1__avanzaProcedimento:
		soap_serialize___ns1__avanzaProcedimento(soap, (const struct __ns1__avanzaProcedimento *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcedimento:
		soap_serialize___ns1__getProcedimento(soap, (const struct __ns1__getProcedimento *)ptr);
		break;
	case SOAP_TYPE___ns1__aggiungiDocumentoAlProcedimento:
		soap_serialize___ns1__aggiungiDocumentoAlProcedimento(soap, (const struct __ns1__aggiungiDocumentoAlProcedimento *)ptr);
		break;
	case SOAP_TYPE___ns1__attivaProcedimentoWide:
		soap_serialize___ns1__attivaProcedimentoWide(soap, (const struct __ns1__attivaProcedimentoWide *)ptr);
		break;
	case SOAP_TYPE___ns1__attivaProcedimento:
		soap_serialize___ns1__attivaProcedimento(soap, (const struct __ns1__attivaProcedimento *)ptr);
		break;
	case SOAP_TYPE___ns1__login:
		soap_serialize___ns1__login(soap, (const struct __ns1__login *)ptr);
		break;
	case SOAP_TYPE___ns1__getToken:
		soap_serialize___ns1__getToken(soap, (const struct __ns1__getToken *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getGiustificativiResponse:
		soap_serialize_PointerTo_ns1__getGiustificativiResponse(soap, (_ns1__getGiustificativiResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getGiustificativi:
		soap_serialize_PointerTo_ns1__getGiustificativi(soap, (_ns1__getGiustificativi *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getFlussiResponse:
		soap_serialize_PointerTo_ns1__getFlussiResponse(soap, (_ns1__getFlussiResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getFlussi:
		soap_serialize_PointerTo_ns1__getFlussi(soap, (_ns1__getFlussi *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__avanzaProcedimentoResponse:
		soap_serialize_PointerTo_ns1__avanzaProcedimentoResponse(soap, (_ns1__avanzaProcedimentoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__avanzaProcedimento:
		soap_serialize_PointerTo_ns1__avanzaProcedimento(soap, (_ns1__avanzaProcedimento *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getProcedimentoResponse:
		soap_serialize_PointerTo_ns1__getProcedimentoResponse(soap, (_ns1__getProcedimentoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getProcedimento:
		soap_serialize_PointerTo_ns1__getProcedimento(soap, (_ns1__getProcedimento *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse:
		soap_serialize_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(soap, (_ns1__aggiungiDocumentoAlProcedimentoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__aggiungiDocumentoAlProcedimento:
		soap_serialize_PointerTo_ns1__aggiungiDocumentoAlProcedimento(soap, (_ns1__aggiungiDocumentoAlProcedimento *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoWideResponse:
		soap_serialize_PointerTo_ns1__attivaProcedimentoWideResponse(soap, (_ns1__attivaProcedimentoWideResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoWide:
		soap_serialize_PointerTo_ns1__attivaProcedimentoWide(soap, (_ns1__attivaProcedimentoWide *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimentoResponse:
		soap_serialize_PointerTo_ns1__attivaProcedimentoResponse(soap, (_ns1__attivaProcedimentoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__attivaProcedimento:
		soap_serialize_PointerTo_ns1__attivaProcedimento(soap, (_ns1__attivaProcedimento *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		soap_serialize_PointerTo_ns1__loginResponse(soap, (_ns1__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__login:
		soap_serialize_PointerTo_ns1__login(soap, (_ns1__login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTokenResponse:
		soap_serialize_PointerTo_ns1__getTokenResponse(soap, (_ns1__getTokenResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getToken:
		soap_serialize_PointerTo_ns1__getToken(soap, (_ns1__getToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EccezioneSistema:
		soap_serialize_PointerTons1__EccezioneSistema(soap, (ns1__EccezioneSistema *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EccezioneAutenticazione:
		soap_serialize_PointerTons1__EccezioneAutenticazione(soap, (ns1__EccezioneAutenticazione *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfFunzione:
		soap_serialize_PointerTons1__ArrayOfFunzione(soap, (ns1__ArrayOfFunzione *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Esito:
		soap_serialize_PointerTons1__Esito(soap, (ns1__Esito *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Giustificativo:
		soap_serialize_PointerToPointerTons1__Giustificativo(soap, (ns1__Giustificativo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Giustificativo:
		soap_serialize_PointerTons1__Giustificativo(soap, (ns1__Giustificativo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Flusso:
		soap_serialize_PointerToPointerTons1__Flusso(soap, (ns1__Flusso **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Flusso:
		soap_serialize_PointerTons1__Flusso(soap, (ns1__Flusso *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Procedimento:
		soap_serialize_PointerTons1__Procedimento(soap, (ns1__Procedimento *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MetaDato:
		soap_serialize_PointerToPointerTons1__MetaDato(soap, (ns1__MetaDato **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MetaDato:
		soap_serialize_PointerTons1__MetaDato(soap, (ns1__MetaDato *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfStepCompetenza:
		soap_serialize_PointerTons1__ArrayOfStepCompetenza(soap, (ns1__ArrayOfStepCompetenza *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfStep:
		soap_serialize_PointerTons1__ArrayOfStep(soap, (ns1__ArrayOfStep *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Stato:
		soap_serialize_PointerTons1__Stato(soap, (ns1__Stato *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfNota:
		soap_serialize_PointerTons1__ArrayOfNota(soap, (ns1__ArrayOfNota *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__StepCompetenza:
		soap_serialize_PointerToPointerTons1__StepCompetenza(soap, (ns1__StepCompetenza **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StepCompetenza:
		soap_serialize_PointerTons1__StepCompetenza(soap, (ns1__StepCompetenza *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Funzione:
		soap_serialize_PointerToPointerTons1__Funzione(soap, (ns1__Funzione **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Funzione:
		soap_serialize_PointerTons1__Funzione(soap, (ns1__Funzione *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfAttributo:
		soap_serialize_PointerTons1__ArrayOfAttributo(soap, (ns1__ArrayOfAttributo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Attributo:
		soap_serialize_PointerToPointerTons1__Attributo(soap, (ns1__Attributo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Attributo:
		soap_serialize_PointerTons1__Attributo(soap, (ns1__Attributo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOf_USCORExsd_USCOREstring:
		soap_serialize_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, (ns1__ArrayOf_USCORExsd_USCOREstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Step:
		soap_serialize_PointerToPointerTons1__Step(soap, (ns1__Step **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Step:
		soap_serialize_PointerTons1__Step(soap, (ns1__Step *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Nota:
		soap_serialize_PointerToPointerTons1__Nota(soap, (ns1__Nota **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Nota:
		soap_serialize_PointerTons1__Nota(soap, (ns1__Nota *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ns1__EccezioneAutenticazione:
		return (void*)soap_instantiate_ns1__EccezioneAutenticazione(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EccezioneSistema:
		return (void*)soap_instantiate_ns1__EccezioneSistema(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MetaDato:
		return (void*)soap_instantiate_ns1__MetaDato(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Nota:
		return (void*)soap_instantiate_ns1__Nota(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfNota:
		return (void*)soap_instantiate_ns1__ArrayOfNota(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Stato:
		return (void*)soap_instantiate_ns1__Stato(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Step:
		return (void*)soap_instantiate_ns1__Step(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfStep:
		return (void*)soap_instantiate_ns1__ArrayOfStep(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring:
		return (void*)soap_instantiate_ns1__ArrayOf_USCORExsd_USCOREstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Esito:
		return (void*)soap_instantiate_ns1__Esito(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Attributo:
		return (void*)soap_instantiate_ns1__Attributo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfAttributo:
		return (void*)soap_instantiate_ns1__ArrayOfAttributo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Funzione:
		return (void*)soap_instantiate_ns1__Funzione(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfFunzione:
		return (void*)soap_instantiate_ns1__ArrayOfFunzione(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfStepCompetenza:
		return (void*)soap_instantiate_ns1__ArrayOfStepCompetenza(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Procedimento:
		return (void*)soap_instantiate_ns1__Procedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Flusso:
		return (void*)soap_instantiate_ns1__Flusso(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Giustificativo:
		return (void*)soap_instantiate_ns1__Giustificativo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getToken:
		return (void*)soap_instantiate__ns1__getToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getTokenResponse:
		return (void*)soap_instantiate__ns1__getTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__login:
		return (void*)soap_instantiate__ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loginResponse:
		return (void*)soap_instantiate__ns1__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__attivaProcedimento:
		return (void*)soap_instantiate__ns1__attivaProcedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__attivaProcedimentoResponse:
		return (void*)soap_instantiate__ns1__attivaProcedimentoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__attivaProcedimentoWide:
		return (void*)soap_instantiate__ns1__attivaProcedimentoWide(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__attivaProcedimentoWideResponse:
		return (void*)soap_instantiate__ns1__attivaProcedimentoWideResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento:
		return (void*)soap_instantiate__ns1__aggiungiDocumentoAlProcedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse:
		return (void*)soap_instantiate__ns1__aggiungiDocumentoAlProcedimentoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getProcedimento:
		return (void*)soap_instantiate__ns1__getProcedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getProcedimentoResponse:
		return (void*)soap_instantiate__ns1__getProcedimentoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__avanzaProcedimento:
		return (void*)soap_instantiate__ns1__avanzaProcedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__avanzaProcedimentoResponse:
		return (void*)soap_instantiate__ns1__avanzaProcedimentoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getFlussi:
		return (void*)soap_instantiate__ns1__getFlussi(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getFlussiResponse:
		return (void*)soap_instantiate__ns1__getFlussiResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getGiustificativi:
		return (void*)soap_instantiate__ns1__getGiustificativi(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getGiustificativiResponse:
		return (void*)soap_instantiate__ns1__getGiustificativiResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StepCompetenza:
		return (void*)soap_instantiate_ns1__StepCompetenza(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__getToken:
		return (void*)soap_instantiate___ns1__getToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__login:
		return (void*)soap_instantiate___ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__attivaProcedimento:
		return (void*)soap_instantiate___ns1__attivaProcedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__attivaProcedimentoWide:
		return (void*)soap_instantiate___ns1__attivaProcedimentoWide(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__aggiungiDocumentoAlProcedimento:
		return (void*)soap_instantiate___ns1__aggiungiDocumentoAlProcedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcedimento:
		return (void*)soap_instantiate___ns1__getProcedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__avanzaProcedimento:
		return (void*)soap_instantiate___ns1__avanzaProcedimento(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getFlussi:
		return (void*)soap_instantiate___ns1__getFlussi(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getGiustificativi:
		return (void*)soap_instantiate___ns1__getGiustificativi(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__EccezioneAutenticazione:
		if (p->size < 0)
			SOAP_DELETE((ns1__EccezioneAutenticazione*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__EccezioneAutenticazione*)p->ptr);
		break;
	case SOAP_TYPE_ns1__EccezioneSistema:
		if (p->size < 0)
			SOAP_DELETE((ns1__EccezioneSistema*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__EccezioneSistema*)p->ptr);
		break;
	case SOAP_TYPE_ns1__MetaDato:
		if (p->size < 0)
			SOAP_DELETE((ns1__MetaDato*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__MetaDato*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Nota:
		if (p->size < 0)
			SOAP_DELETE((ns1__Nota*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Nota*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfNota:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfNota*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfNota*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Stato:
		if (p->size < 0)
			SOAP_DELETE((ns1__Stato*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Stato*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Step:
		if (p->size < 0)
			SOAP_DELETE((ns1__Step*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Step*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfStep:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfStep*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfStep*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOf_USCORExsd_USCOREstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOf_USCORExsd_USCOREstring*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Esito:
		if (p->size < 0)
			SOAP_DELETE((ns1__Esito*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Esito*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Attributo:
		if (p->size < 0)
			SOAP_DELETE((ns1__Attributo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Attributo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfAttributo:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfAttributo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfAttributo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Funzione:
		if (p->size < 0)
			SOAP_DELETE((ns1__Funzione*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Funzione*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfFunzione:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfFunzione*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfFunzione*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfStepCompetenza:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfStepCompetenza*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfStepCompetenza*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Procedimento:
		if (p->size < 0)
			SOAP_DELETE((ns1__Procedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Procedimento*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Flusso:
		if (p->size < 0)
			SOAP_DELETE((ns1__Flusso*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Flusso*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Giustificativo:
		if (p->size < 0)
			SOAP_DELETE((ns1__Giustificativo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Giustificativo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getToken:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getToken*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getTokenResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getTokenResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getTokenResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__login:
		if (p->size < 0)
			SOAP_DELETE((_ns1__login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__login*)p->ptr);
		break;
	case SOAP_TYPE__ns1__loginResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__loginResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__loginResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__attivaProcedimento:
		if (p->size < 0)
			SOAP_DELETE((_ns1__attivaProcedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__attivaProcedimento*)p->ptr);
		break;
	case SOAP_TYPE__ns1__attivaProcedimentoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__attivaProcedimentoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__attivaProcedimentoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__attivaProcedimentoWide:
		if (p->size < 0)
			SOAP_DELETE((_ns1__attivaProcedimentoWide*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__attivaProcedimentoWide*)p->ptr);
		break;
	case SOAP_TYPE__ns1__attivaProcedimentoWideResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__attivaProcedimentoWideResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__attivaProcedimentoWideResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento:
		if (p->size < 0)
			SOAP_DELETE((_ns1__aggiungiDocumentoAlProcedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__aggiungiDocumentoAlProcedimento*)p->ptr);
		break;
	case SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__aggiungiDocumentoAlProcedimentoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__aggiungiDocumentoAlProcedimentoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getProcedimento:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getProcedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getProcedimento*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getProcedimentoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getProcedimentoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getProcedimentoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__avanzaProcedimento:
		if (p->size < 0)
			SOAP_DELETE((_ns1__avanzaProcedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__avanzaProcedimento*)p->ptr);
		break;
	case SOAP_TYPE__ns1__avanzaProcedimentoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__avanzaProcedimentoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__avanzaProcedimentoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getFlussi:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getFlussi*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getFlussi*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getFlussiResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getFlussiResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getFlussiResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getGiustificativi:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getGiustificativi*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getGiustificativi*)p->ptr);
		break;
	case SOAP_TYPE__ns1__getGiustificativiResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__getGiustificativiResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__getGiustificativiResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StepCompetenza:
		if (p->size < 0)
			SOAP_DELETE((ns1__StepCompetenza*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__StepCompetenza*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___ns1__getToken:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getToken*)p->ptr);
		break;
	case SOAP_TYPE___ns1__login:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__login*)p->ptr);
		break;
	case SOAP_TYPE___ns1__attivaProcedimento:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__attivaProcedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__attivaProcedimento*)p->ptr);
		break;
	case SOAP_TYPE___ns1__attivaProcedimentoWide:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__attivaProcedimentoWide*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__attivaProcedimentoWide*)p->ptr);
		break;
	case SOAP_TYPE___ns1__aggiungiDocumentoAlProcedimento:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__aggiungiDocumentoAlProcedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__aggiungiDocumentoAlProcedimento*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcedimento:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcedimento*)p->ptr);
		break;
	case SOAP_TYPE___ns1__avanzaProcedimento:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__avanzaProcedimento*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__avanzaProcedimento*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getFlussi:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getFlussi*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getFlussi*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getGiustificativi:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getGiustificativi*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getGiustificativi*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getGiustificativiResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getGiustificativiResponse::__sizegetGiustificativiReturn = 0;
	this->_ns1__getGiustificativiResponse::getGiustificativiReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getGiustificativiResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getGiustificativiResponse::getGiustificativiReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getGiustificativiResponse::__sizegetGiustificativiReturn; i++)
		{
			soap_serialize_PointerTons1__Giustificativo(soap, this->_ns1__getGiustificativiResponse::getGiustificativiReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getGiustificativiResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getGiustificativiResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getGiustificativiResponse(struct soap *soap, const char *tag, int id, const _ns1__getGiustificativiResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getGiustificativiResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetGiustificativiReturn");
	if (a->_ns1__getGiustificativiResponse::getGiustificativiReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getGiustificativiResponse::__sizegetGiustificativiReturn; i++)
			if (soap_out_PointerTons1__Giustificativo(soap, "ns1:getGiustificativiReturn", -1, a->_ns1__getGiustificativiResponse::getGiustificativiReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getGiustificativiResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getGiustificativiResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getGiustificativiResponse * SOAP_FMAC4 soap_in__ns1__getGiustificativiResponse(struct soap *soap, const char *tag, _ns1__getGiustificativiResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getGiustificativiResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getGiustificativiResponse, sizeof(_ns1__getGiustificativiResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getGiustificativiResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getGiustificativiResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getGiustificativiReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getGiustificativiReturn", 1, NULL))
			{	if (a->_ns1__getGiustificativiResponse::getGiustificativiReturn == NULL)
				{	if (soap_blist_getGiustificativiReturn1 == NULL)
						soap_blist_getGiustificativiReturn1 = soap_new_block(soap);
					a->_ns1__getGiustificativiResponse::getGiustificativiReturn = (ns1__Giustificativo **)soap_push_block(soap, soap_blist_getGiustificativiReturn1, sizeof(ns1__Giustificativo *));
					if (a->_ns1__getGiustificativiResponse::getGiustificativiReturn == NULL)
						return NULL;
					*a->_ns1__getGiustificativiResponse::getGiustificativiReturn = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Giustificativo(soap, "ns1:getGiustificativiReturn", a->_ns1__getGiustificativiResponse::getGiustificativiReturn, "ns1:Giustificativo"))
				{	a->_ns1__getGiustificativiResponse::__sizegetGiustificativiReturn++;
					a->_ns1__getGiustificativiResponse::getGiustificativiReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetGiustificativiReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getGiustificativiResponse::getGiustificativiReturn)
			soap_pop_block(soap, soap_blist_getGiustificativiReturn1);
		if (a->_ns1__getGiustificativiResponse::__sizegetGiustificativiReturn)
			a->_ns1__getGiustificativiResponse::getGiustificativiReturn = (ns1__Giustificativo **)soap_save_block(soap, soap_blist_getGiustificativiReturn1, NULL, 1);
		else
		{	a->_ns1__getGiustificativiResponse::getGiustificativiReturn = NULL;
			if (soap_blist_getGiustificativiReturn1)
				soap_end_block(soap, soap_blist_getGiustificativiReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getGiustificativiResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getGiustificativiResponse, 0, sizeof(_ns1__getGiustificativiResponse), 0, soap_copy__ns1__getGiustificativiResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getGiustificativiResponse::__sizegetGiustificativiReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getGiustificativiResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getGiustificativiResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getGiustificativiResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getGiustificativiResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getGiustificativiResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getGiustificativiResponse * SOAP_FMAC4 soap_get__ns1__getGiustificativiResponse(struct soap *soap, _ns1__getGiustificativiResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getGiustificativiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getGiustificativiResponse * SOAP_FMAC2 soap_instantiate__ns1__getGiustificativiResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getGiustificativiResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getGiustificativiResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getGiustificativiResponse);
		if (size)
			*size = sizeof(_ns1__getGiustificativiResponse);
		((_ns1__getGiustificativiResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getGiustificativiResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getGiustificativiResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getGiustificativiResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getGiustificativiResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getGiustificativiResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getGiustificativiResponse %p -> %p\n", q, p));
	*(_ns1__getGiustificativiResponse*)p = *(_ns1__getGiustificativiResponse*)q;
}

void _ns1__getGiustificativi::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getGiustificativi::token);
	soap_default_string(soap, &this->_ns1__getGiustificativi::anno);
	soap_default_string(soap, &this->_ns1__getGiustificativi::mese);
	soap_default_string(soap, &this->_ns1__getGiustificativi::esito);
	soap_default_string(soap, &this->_ns1__getGiustificativi::codiceFlusso);
	soap_default_LONG64(soap, &this->_ns1__getGiustificativi::idAmministrazione);
	soap_default_LONG64(soap, &this->_ns1__getGiustificativi::idAoo);
	/* transient soap skipped */
}

void _ns1__getGiustificativi::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getGiustificativi::token);
	soap_serialize_string(soap, &this->_ns1__getGiustificativi::anno);
	soap_serialize_string(soap, &this->_ns1__getGiustificativi::mese);
	soap_serialize_string(soap, &this->_ns1__getGiustificativi::esito);
	soap_serialize_string(soap, &this->_ns1__getGiustificativi::codiceFlusso);
	/* transient soap skipped */
}

int _ns1__getGiustificativi::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getGiustificativi(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getGiustificativi(struct soap *soap, const char *tag, int id, const _ns1__getGiustificativi *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getGiustificativi), type))
		return soap->error;
	if (a->_ns1__getGiustificativi::token)
	{	if (soap_out_string(soap, "ns1:token", -1, &a->_ns1__getGiustificativi::token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:token"))
		return soap->error;
	if (a->_ns1__getGiustificativi::anno)
	{	if (soap_out_string(soap, "ns1:anno", -1, &a->_ns1__getGiustificativi::anno, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:anno"))
		return soap->error;
	if (a->_ns1__getGiustificativi::mese)
	{	if (soap_out_string(soap, "ns1:mese", -1, &a->_ns1__getGiustificativi::mese, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:mese"))
		return soap->error;
	if (a->_ns1__getGiustificativi::esito)
	{	if (soap_out_string(soap, "ns1:esito", -1, &a->_ns1__getGiustificativi::esito, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:esito"))
		return soap->error;
	if (a->_ns1__getGiustificativi::codiceFlusso)
	{	if (soap_out_string(soap, "ns1:codiceFlusso", -1, &a->_ns1__getGiustificativi::codiceFlusso, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:codiceFlusso"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAmministrazione", -1, &(a->_ns1__getGiustificativi::idAmministrazione), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAoo", -1, &(a->_ns1__getGiustificativi::idAoo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getGiustificativi::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getGiustificativi(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getGiustificativi * SOAP_FMAC4 soap_in__ns1__getGiustificativi(struct soap *soap, const char *tag, _ns1__getGiustificativi *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getGiustificativi *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getGiustificativi, sizeof(_ns1__getGiustificativi), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getGiustificativi)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getGiustificativi *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	size_t soap_flag_anno1 = 1;
	size_t soap_flag_mese1 = 1;
	size_t soap_flag_esito1 = 1;
	size_t soap_flag_codiceFlusso1 = 1;
	size_t soap_flag_idAmministrazione1 = 1;
	size_t soap_flag_idAoo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &(a->_ns1__getGiustificativi::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_anno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:anno", &(a->_ns1__getGiustificativi::anno), "xsd:string"))
				{	soap_flag_anno1--;
					continue;
				}
			if (soap_flag_mese1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:mese", &(a->_ns1__getGiustificativi::mese), "xsd:string"))
				{	soap_flag_mese1--;
					continue;
				}
			if (soap_flag_esito1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:esito", &(a->_ns1__getGiustificativi::esito), "xsd:string"))
				{	soap_flag_esito1--;
					continue;
				}
			if (soap_flag_codiceFlusso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:codiceFlusso", &(a->_ns1__getGiustificativi::codiceFlusso), "xsd:string"))
				{	soap_flag_codiceFlusso1--;
					continue;
				}
			if (soap_flag_idAmministrazione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAmministrazione", &(a->_ns1__getGiustificativi::idAmministrazione), "xsd:long"))
				{	soap_flag_idAmministrazione1--;
					continue;
				}
			if (soap_flag_idAoo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAoo", &(a->_ns1__getGiustificativi::idAoo), "xsd:long"))
				{	soap_flag_idAoo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getGiustificativi *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getGiustificativi, 0, sizeof(_ns1__getGiustificativi), 0, soap_copy__ns1__getGiustificativi);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token1 > 0 || soap_flag_anno1 > 0 || soap_flag_mese1 > 0 || soap_flag_esito1 > 0 || soap_flag_codiceFlusso1 > 0 || soap_flag_idAmministrazione1 > 0 || soap_flag_idAoo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getGiustificativi::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getGiustificativi);
	if (this->soap_out(soap, tag?tag:"ns1:getGiustificativi", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getGiustificativi::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getGiustificativi(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getGiustificativi * SOAP_FMAC4 soap_get__ns1__getGiustificativi(struct soap *soap, _ns1__getGiustificativi *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getGiustificativi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getGiustificativi * SOAP_FMAC2 soap_instantiate__ns1__getGiustificativi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getGiustificativi(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getGiustificativi, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getGiustificativi);
		if (size)
			*size = sizeof(_ns1__getGiustificativi);
		((_ns1__getGiustificativi*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getGiustificativi[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getGiustificativi);
		for (int i = 0; i < n; i++)
			((_ns1__getGiustificativi*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getGiustificativi*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getGiustificativi(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getGiustificativi %p -> %p\n", q, p));
	*(_ns1__getGiustificativi*)p = *(_ns1__getGiustificativi*)q;
}

void _ns1__getFlussiResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getFlussiResponse::__sizegetFlussiReturn = 0;
	this->_ns1__getFlussiResponse::getFlussiReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getFlussiResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__getFlussiResponse::getFlussiReturn)
	{	int i;
		for (i = 0; i < this->_ns1__getFlussiResponse::__sizegetFlussiReturn; i++)
		{
			soap_serialize_PointerTons1__Flusso(soap, this->_ns1__getFlussiResponse::getFlussiReturn + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__getFlussiResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getFlussiResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getFlussiResponse(struct soap *soap, const char *tag, int id, const _ns1__getFlussiResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getFlussiResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizegetFlussiReturn");
	if (a->_ns1__getFlussiResponse::getFlussiReturn)
	{	int i;
		for (i = 0; i < a->_ns1__getFlussiResponse::__sizegetFlussiReturn; i++)
			if (soap_out_PointerTons1__Flusso(soap, "ns1:getFlussiReturn", -1, a->_ns1__getFlussiResponse::getFlussiReturn + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getFlussiResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getFlussiResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getFlussiResponse * SOAP_FMAC4 soap_in__ns1__getFlussiResponse(struct soap *soap, const char *tag, _ns1__getFlussiResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getFlussiResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFlussiResponse, sizeof(_ns1__getFlussiResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getFlussiResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getFlussiResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_getFlussiReturn1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:getFlussiReturn", 1, NULL))
			{	if (a->_ns1__getFlussiResponse::getFlussiReturn == NULL)
				{	if (soap_blist_getFlussiReturn1 == NULL)
						soap_blist_getFlussiReturn1 = soap_new_block(soap);
					a->_ns1__getFlussiResponse::getFlussiReturn = (ns1__Flusso **)soap_push_block(soap, soap_blist_getFlussiReturn1, sizeof(ns1__Flusso *));
					if (a->_ns1__getFlussiResponse::getFlussiReturn == NULL)
						return NULL;
					*a->_ns1__getFlussiResponse::getFlussiReturn = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Flusso(soap, "ns1:getFlussiReturn", a->_ns1__getFlussiResponse::getFlussiReturn, "ns1:Flusso"))
				{	a->_ns1__getFlussiResponse::__sizegetFlussiReturn++;
					a->_ns1__getFlussiResponse::getFlussiReturn = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizegetFlussiReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__getFlussiResponse::getFlussiReturn)
			soap_pop_block(soap, soap_blist_getFlussiReturn1);
		if (a->_ns1__getFlussiResponse::__sizegetFlussiReturn)
			a->_ns1__getFlussiResponse::getFlussiReturn = (ns1__Flusso **)soap_save_block(soap, soap_blist_getFlussiReturn1, NULL, 1);
		else
		{	a->_ns1__getFlussiResponse::getFlussiReturn = NULL;
			if (soap_blist_getFlussiReturn1)
				soap_end_block(soap, soap_blist_getFlussiReturn1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getFlussiResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getFlussiResponse, 0, sizeof(_ns1__getFlussiResponse), 0, soap_copy__ns1__getFlussiResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__getFlussiResponse::__sizegetFlussiReturn < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getFlussiResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getFlussiResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getFlussiResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getFlussiResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getFlussiResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getFlussiResponse * SOAP_FMAC4 soap_get__ns1__getFlussiResponse(struct soap *soap, _ns1__getFlussiResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getFlussiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getFlussiResponse * SOAP_FMAC2 soap_instantiate__ns1__getFlussiResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getFlussiResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getFlussiResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getFlussiResponse);
		if (size)
			*size = sizeof(_ns1__getFlussiResponse);
		((_ns1__getFlussiResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getFlussiResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getFlussiResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getFlussiResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getFlussiResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getFlussiResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getFlussiResponse %p -> %p\n", q, p));
	*(_ns1__getFlussiResponse*)p = *(_ns1__getFlussiResponse*)q;
}

void _ns1__getFlussi::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getFlussi::token);
	soap_default_string(soap, &this->_ns1__getFlussi::username);
	soap_default_LONG64(soap, &this->_ns1__getFlussi::idAmministrazione);
	soap_default_LONG64(soap, &this->_ns1__getFlussi::idAoo);
	/* transient soap skipped */
}

void _ns1__getFlussi::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getFlussi::token);
	soap_serialize_string(soap, &this->_ns1__getFlussi::username);
	/* transient soap skipped */
}

int _ns1__getFlussi::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getFlussi(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getFlussi(struct soap *soap, const char *tag, int id, const _ns1__getFlussi *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getFlussi), type))
		return soap->error;
	if (a->_ns1__getFlussi::token)
	{	if (soap_out_string(soap, "ns1:token", -1, &a->_ns1__getFlussi::token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:token"))
		return soap->error;
	if (a->_ns1__getFlussi::username)
	{	if (soap_out_string(soap, "ns1:username", -1, &a->_ns1__getFlussi::username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:username"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAmministrazione", -1, &(a->_ns1__getFlussi::idAmministrazione), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAoo", -1, &(a->_ns1__getFlussi::idAoo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getFlussi::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getFlussi(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getFlussi * SOAP_FMAC4 soap_in__ns1__getFlussi(struct soap *soap, const char *tag, _ns1__getFlussi *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getFlussi *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFlussi, sizeof(_ns1__getFlussi), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getFlussi)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getFlussi *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_idAmministrazione1 = 1;
	size_t soap_flag_idAoo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &(a->_ns1__getFlussi::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__getFlussi::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_idAmministrazione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAmministrazione", &(a->_ns1__getFlussi::idAmministrazione), "xsd:long"))
				{	soap_flag_idAmministrazione1--;
					continue;
				}
			if (soap_flag_idAoo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAoo", &(a->_ns1__getFlussi::idAoo), "xsd:long"))
				{	soap_flag_idAoo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getFlussi *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getFlussi, 0, sizeof(_ns1__getFlussi), 0, soap_copy__ns1__getFlussi);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token1 > 0 || soap_flag_username1 > 0 || soap_flag_idAmministrazione1 > 0 || soap_flag_idAoo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getFlussi::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getFlussi);
	if (this->soap_out(soap, tag?tag:"ns1:getFlussi", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getFlussi::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getFlussi(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getFlussi * SOAP_FMAC4 soap_get__ns1__getFlussi(struct soap *soap, _ns1__getFlussi *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getFlussi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getFlussi * SOAP_FMAC2 soap_instantiate__ns1__getFlussi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getFlussi(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getFlussi, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getFlussi);
		if (size)
			*size = sizeof(_ns1__getFlussi);
		((_ns1__getFlussi*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getFlussi[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getFlussi);
		for (int i = 0; i < n; i++)
			((_ns1__getFlussi*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getFlussi*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getFlussi(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getFlussi %p -> %p\n", q, p));
	*(_ns1__getFlussi*)p = *(_ns1__getFlussi*)q;
}

void _ns1__avanzaProcedimentoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__avanzaProcedimentoResponse::avanzaProcedimentoReturn = NULL;
	/* transient soap skipped */
}

void _ns1__avanzaProcedimentoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Procedimento(soap, &this->_ns1__avanzaProcedimentoResponse::avanzaProcedimentoReturn);
	/* transient soap skipped */
}

int _ns1__avanzaProcedimentoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__avanzaProcedimentoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__avanzaProcedimentoResponse(struct soap *soap, const char *tag, int id, const _ns1__avanzaProcedimentoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__avanzaProcedimentoResponse), type))
		return soap->error;
	if (a->avanzaProcedimentoReturn)
		soap_element_result(soap, "ns1:avanzaProcedimentoReturn");
	if (a->_ns1__avanzaProcedimentoResponse::avanzaProcedimentoReturn)
	{	if (soap_out_PointerTons1__Procedimento(soap, "ns1:avanzaProcedimentoReturn", -1, &a->_ns1__avanzaProcedimentoResponse::avanzaProcedimentoReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:avanzaProcedimentoReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__avanzaProcedimentoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__avanzaProcedimentoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__avanzaProcedimentoResponse * SOAP_FMAC4 soap_in__ns1__avanzaProcedimentoResponse(struct soap *soap, const char *tag, _ns1__avanzaProcedimentoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__avanzaProcedimentoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__avanzaProcedimentoResponse, sizeof(_ns1__avanzaProcedimentoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__avanzaProcedimentoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__avanzaProcedimentoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_avanzaProcedimentoReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_avanzaProcedimentoReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Procedimento(soap, "ns1:avanzaProcedimentoReturn", &(a->_ns1__avanzaProcedimentoResponse::avanzaProcedimentoReturn), "ns1:Procedimento"))
				{	soap_flag_avanzaProcedimentoReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:avanzaProcedimentoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__avanzaProcedimentoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__avanzaProcedimentoResponse, 0, sizeof(_ns1__avanzaProcedimentoResponse), 0, soap_copy__ns1__avanzaProcedimentoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_avanzaProcedimentoReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__avanzaProcedimentoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__avanzaProcedimentoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:avanzaProcedimentoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__avanzaProcedimentoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__avanzaProcedimentoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__avanzaProcedimentoResponse * SOAP_FMAC4 soap_get__ns1__avanzaProcedimentoResponse(struct soap *soap, _ns1__avanzaProcedimentoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__avanzaProcedimentoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__avanzaProcedimentoResponse * SOAP_FMAC2 soap_instantiate__ns1__avanzaProcedimentoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__avanzaProcedimentoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__avanzaProcedimentoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__avanzaProcedimentoResponse);
		if (size)
			*size = sizeof(_ns1__avanzaProcedimentoResponse);
		((_ns1__avanzaProcedimentoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__avanzaProcedimentoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__avanzaProcedimentoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__avanzaProcedimentoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__avanzaProcedimentoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__avanzaProcedimentoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__avanzaProcedimentoResponse %p -> %p\n", q, p));
	*(_ns1__avanzaProcedimentoResponse*)p = *(_ns1__avanzaProcedimentoResponse*)q;
}

void _ns1__avanzaProcedimento::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__avanzaProcedimento::token);
	soap_default_string(soap, &this->_ns1__avanzaProcedimento::username);
	soap_default_LONG64(soap, &this->_ns1__avanzaProcedimento::idAmministrazione);
	soap_default_LONG64(soap, &this->_ns1__avanzaProcedimento::idAoo);
	soap_default_string(soap, &this->_ns1__avanzaProcedimento::idProcedimento);
	soap_default_string(soap, &this->_ns1__avanzaProcedimento::idStep);
	soap_default_string(soap, &this->_ns1__avanzaProcedimento::valoreEsito);
	soap_default_string(soap, &this->_ns1__avanzaProcedimento::note);
	/* transient soap skipped */
}

void _ns1__avanzaProcedimento::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__avanzaProcedimento::token);
	soap_serialize_string(soap, &this->_ns1__avanzaProcedimento::username);
	soap_serialize_string(soap, &this->_ns1__avanzaProcedimento::idProcedimento);
	soap_serialize_string(soap, &this->_ns1__avanzaProcedimento::idStep);
	soap_serialize_string(soap, &this->_ns1__avanzaProcedimento::valoreEsito);
	soap_serialize_string(soap, &this->_ns1__avanzaProcedimento::note);
	/* transient soap skipped */
}

int _ns1__avanzaProcedimento::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__avanzaProcedimento(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__avanzaProcedimento(struct soap *soap, const char *tag, int id, const _ns1__avanzaProcedimento *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__avanzaProcedimento), type))
		return soap->error;
	if (a->_ns1__avanzaProcedimento::token)
	{	if (soap_out_string(soap, "ns1:token", -1, &a->_ns1__avanzaProcedimento::token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:token"))
		return soap->error;
	if (a->_ns1__avanzaProcedimento::username)
	{	if (soap_out_string(soap, "ns1:username", -1, &a->_ns1__avanzaProcedimento::username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:username"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAmministrazione", -1, &(a->_ns1__avanzaProcedimento::idAmministrazione), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAoo", -1, &(a->_ns1__avanzaProcedimento::idAoo), ""))
		return soap->error;
	if (a->_ns1__avanzaProcedimento::idProcedimento)
	{	if (soap_out_string(soap, "ns1:idProcedimento", -1, &a->_ns1__avanzaProcedimento::idProcedimento, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:idProcedimento"))
		return soap->error;
	if (a->_ns1__avanzaProcedimento::idStep)
	{	if (soap_out_string(soap, "ns1:idStep", -1, &a->_ns1__avanzaProcedimento::idStep, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:idStep"))
		return soap->error;
	if (a->_ns1__avanzaProcedimento::valoreEsito)
	{	if (soap_out_string(soap, "ns1:valoreEsito", -1, &a->_ns1__avanzaProcedimento::valoreEsito, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:valoreEsito"))
		return soap->error;
	if (a->_ns1__avanzaProcedimento::note)
	{	if (soap_out_string(soap, "ns1:note", -1, &a->_ns1__avanzaProcedimento::note, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:note"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__avanzaProcedimento::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__avanzaProcedimento(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__avanzaProcedimento * SOAP_FMAC4 soap_in__ns1__avanzaProcedimento(struct soap *soap, const char *tag, _ns1__avanzaProcedimento *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__avanzaProcedimento *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__avanzaProcedimento, sizeof(_ns1__avanzaProcedimento), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__avanzaProcedimento)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__avanzaProcedimento *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_idAmministrazione1 = 1;
	size_t soap_flag_idAoo1 = 1;
	size_t soap_flag_idProcedimento1 = 1;
	size_t soap_flag_idStep1 = 1;
	size_t soap_flag_valoreEsito1 = 1;
	size_t soap_flag_note1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &(a->_ns1__avanzaProcedimento::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__avanzaProcedimento::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_idAmministrazione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAmministrazione", &(a->_ns1__avanzaProcedimento::idAmministrazione), "xsd:long"))
				{	soap_flag_idAmministrazione1--;
					continue;
				}
			if (soap_flag_idAoo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAoo", &(a->_ns1__avanzaProcedimento::idAoo), "xsd:long"))
				{	soap_flag_idAoo1--;
					continue;
				}
			if (soap_flag_idProcedimento1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:idProcedimento", &(a->_ns1__avanzaProcedimento::idProcedimento), "xsd:string"))
				{	soap_flag_idProcedimento1--;
					continue;
				}
			if (soap_flag_idStep1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:idStep", &(a->_ns1__avanzaProcedimento::idStep), "xsd:string"))
				{	soap_flag_idStep1--;
					continue;
				}
			if (soap_flag_valoreEsito1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:valoreEsito", &(a->_ns1__avanzaProcedimento::valoreEsito), "xsd:string"))
				{	soap_flag_valoreEsito1--;
					continue;
				}
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:note", &(a->_ns1__avanzaProcedimento::note), "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__avanzaProcedimento *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__avanzaProcedimento, 0, sizeof(_ns1__avanzaProcedimento), 0, soap_copy__ns1__avanzaProcedimento);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token1 > 0 || soap_flag_username1 > 0 || soap_flag_idAmministrazione1 > 0 || soap_flag_idAoo1 > 0 || soap_flag_idProcedimento1 > 0 || soap_flag_idStep1 > 0 || soap_flag_valoreEsito1 > 0 || soap_flag_note1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__avanzaProcedimento::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__avanzaProcedimento);
	if (this->soap_out(soap, tag?tag:"ns1:avanzaProcedimento", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__avanzaProcedimento::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__avanzaProcedimento(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__avanzaProcedimento * SOAP_FMAC4 soap_get__ns1__avanzaProcedimento(struct soap *soap, _ns1__avanzaProcedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__avanzaProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__avanzaProcedimento * SOAP_FMAC2 soap_instantiate__ns1__avanzaProcedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__avanzaProcedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__avanzaProcedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__avanzaProcedimento);
		if (size)
			*size = sizeof(_ns1__avanzaProcedimento);
		((_ns1__avanzaProcedimento*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__avanzaProcedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__avanzaProcedimento);
		for (int i = 0; i < n; i++)
			((_ns1__avanzaProcedimento*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__avanzaProcedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__avanzaProcedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__avanzaProcedimento %p -> %p\n", q, p));
	*(_ns1__avanzaProcedimento*)p = *(_ns1__avanzaProcedimento*)q;
}

void _ns1__getProcedimentoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getProcedimentoResponse::getProcedimentoReturn = NULL;
	/* transient soap skipped */
}

void _ns1__getProcedimentoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Procedimento(soap, &this->_ns1__getProcedimentoResponse::getProcedimentoReturn);
	/* transient soap skipped */
}

int _ns1__getProcedimentoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getProcedimentoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getProcedimentoResponse(struct soap *soap, const char *tag, int id, const _ns1__getProcedimentoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getProcedimentoResponse), type))
		return soap->error;
	if (a->getProcedimentoReturn)
		soap_element_result(soap, "ns1:getProcedimentoReturn");
	if (a->_ns1__getProcedimentoResponse::getProcedimentoReturn)
	{	if (soap_out_PointerTons1__Procedimento(soap, "ns1:getProcedimentoReturn", -1, &a->_ns1__getProcedimentoResponse::getProcedimentoReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getProcedimentoReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getProcedimentoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getProcedimentoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getProcedimentoResponse * SOAP_FMAC4 soap_in__ns1__getProcedimentoResponse(struct soap *soap, const char *tag, _ns1__getProcedimentoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getProcedimentoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getProcedimentoResponse, sizeof(_ns1__getProcedimentoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getProcedimentoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getProcedimentoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getProcedimentoReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getProcedimentoReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Procedimento(soap, "ns1:getProcedimentoReturn", &(a->_ns1__getProcedimentoResponse::getProcedimentoReturn), "ns1:Procedimento"))
				{	soap_flag_getProcedimentoReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getProcedimentoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getProcedimentoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getProcedimentoResponse, 0, sizeof(_ns1__getProcedimentoResponse), 0, soap_copy__ns1__getProcedimentoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getProcedimentoReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getProcedimentoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getProcedimentoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcedimentoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getProcedimentoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getProcedimentoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getProcedimentoResponse * SOAP_FMAC4 soap_get__ns1__getProcedimentoResponse(struct soap *soap, _ns1__getProcedimentoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getProcedimentoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getProcedimentoResponse * SOAP_FMAC2 soap_instantiate__ns1__getProcedimentoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getProcedimentoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getProcedimentoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getProcedimentoResponse);
		if (size)
			*size = sizeof(_ns1__getProcedimentoResponse);
		((_ns1__getProcedimentoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getProcedimentoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getProcedimentoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getProcedimentoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getProcedimentoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getProcedimentoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getProcedimentoResponse %p -> %p\n", q, p));
	*(_ns1__getProcedimentoResponse*)p = *(_ns1__getProcedimentoResponse*)q;
}

void _ns1__getProcedimento::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getProcedimento::token);
	soap_default_string(soap, &this->_ns1__getProcedimento::username);
	soap_default_LONG64(soap, &this->_ns1__getProcedimento::idAmministrazione);
	soap_default_LONG64(soap, &this->_ns1__getProcedimento::idAoo);
	soap_default_string(soap, &this->_ns1__getProcedimento::idProcedimento);
	/* transient soap skipped */
}

void _ns1__getProcedimento::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getProcedimento::token);
	soap_serialize_string(soap, &this->_ns1__getProcedimento::username);
	soap_serialize_string(soap, &this->_ns1__getProcedimento::idProcedimento);
	/* transient soap skipped */
}

int _ns1__getProcedimento::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getProcedimento(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getProcedimento(struct soap *soap, const char *tag, int id, const _ns1__getProcedimento *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getProcedimento), type))
		return soap->error;
	if (a->_ns1__getProcedimento::token)
	{	if (soap_out_string(soap, "ns1:token", -1, &a->_ns1__getProcedimento::token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:token"))
		return soap->error;
	if (a->_ns1__getProcedimento::username)
	{	if (soap_out_string(soap, "ns1:username", -1, &a->_ns1__getProcedimento::username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:username"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAmministrazione", -1, &(a->_ns1__getProcedimento::idAmministrazione), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAoo", -1, &(a->_ns1__getProcedimento::idAoo), ""))
		return soap->error;
	if (a->_ns1__getProcedimento::idProcedimento)
	{	if (soap_out_string(soap, "ns1:idProcedimento", -1, &a->_ns1__getProcedimento::idProcedimento, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:idProcedimento"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getProcedimento::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getProcedimento(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getProcedimento * SOAP_FMAC4 soap_in__ns1__getProcedimento(struct soap *soap, const char *tag, _ns1__getProcedimento *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getProcedimento *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getProcedimento, sizeof(_ns1__getProcedimento), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getProcedimento)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getProcedimento *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_idAmministrazione1 = 1;
	size_t soap_flag_idAoo1 = 1;
	size_t soap_flag_idProcedimento1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &(a->_ns1__getProcedimento::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__getProcedimento::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_idAmministrazione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAmministrazione", &(a->_ns1__getProcedimento::idAmministrazione), "xsd:long"))
				{	soap_flag_idAmministrazione1--;
					continue;
				}
			if (soap_flag_idAoo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAoo", &(a->_ns1__getProcedimento::idAoo), "xsd:long"))
				{	soap_flag_idAoo1--;
					continue;
				}
			if (soap_flag_idProcedimento1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:idProcedimento", &(a->_ns1__getProcedimento::idProcedimento), "xsd:string"))
				{	soap_flag_idProcedimento1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getProcedimento *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getProcedimento, 0, sizeof(_ns1__getProcedimento), 0, soap_copy__ns1__getProcedimento);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token1 > 0 || soap_flag_username1 > 0 || soap_flag_idAmministrazione1 > 0 || soap_flag_idAoo1 > 0 || soap_flag_idProcedimento1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getProcedimento::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getProcedimento);
	if (this->soap_out(soap, tag?tag:"ns1:getProcedimento", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getProcedimento::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getProcedimento(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getProcedimento * SOAP_FMAC4 soap_get__ns1__getProcedimento(struct soap *soap, _ns1__getProcedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getProcedimento * SOAP_FMAC2 soap_instantiate__ns1__getProcedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getProcedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getProcedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getProcedimento);
		if (size)
			*size = sizeof(_ns1__getProcedimento);
		((_ns1__getProcedimento*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getProcedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getProcedimento);
		for (int i = 0; i < n; i++)
			((_ns1__getProcedimento*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getProcedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getProcedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getProcedimento %p -> %p\n", q, p));
	*(_ns1__getProcedimento*)p = *(_ns1__getProcedimento*)q;
}

void _ns1__aggiungiDocumentoAlProcedimentoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__aggiungiDocumentoAlProcedimentoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__aggiungiDocumentoAlProcedimentoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__aggiungiDocumentoAlProcedimentoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, const char *tag, int id, const _ns1__aggiungiDocumentoAlProcedimentoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__aggiungiDocumentoAlProcedimentoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__aggiungiDocumentoAlProcedimentoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__aggiungiDocumentoAlProcedimentoResponse * SOAP_FMAC4 soap_in__ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, const char *tag, _ns1__aggiungiDocumentoAlProcedimentoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__aggiungiDocumentoAlProcedimentoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse, sizeof(_ns1__aggiungiDocumentoAlProcedimentoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__aggiungiDocumentoAlProcedimentoResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__aggiungiDocumentoAlProcedimentoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse, 0, sizeof(_ns1__aggiungiDocumentoAlProcedimentoResponse), 0, soap_copy__ns1__aggiungiDocumentoAlProcedimentoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__aggiungiDocumentoAlProcedimentoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:aggiungiDocumentoAlProcedimentoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__aggiungiDocumentoAlProcedimentoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__aggiungiDocumentoAlProcedimentoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__aggiungiDocumentoAlProcedimentoResponse * SOAP_FMAC4 soap_get__ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, _ns1__aggiungiDocumentoAlProcedimentoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__aggiungiDocumentoAlProcedimentoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__aggiungiDocumentoAlProcedimentoResponse * SOAP_FMAC2 soap_instantiate__ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__aggiungiDocumentoAlProcedimentoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__aggiungiDocumentoAlProcedimentoResponse);
		if (size)
			*size = sizeof(_ns1__aggiungiDocumentoAlProcedimentoResponse);
		((_ns1__aggiungiDocumentoAlProcedimentoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__aggiungiDocumentoAlProcedimentoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__aggiungiDocumentoAlProcedimentoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__aggiungiDocumentoAlProcedimentoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__aggiungiDocumentoAlProcedimentoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__aggiungiDocumentoAlProcedimentoResponse %p -> %p\n", q, p));
	*(_ns1__aggiungiDocumentoAlProcedimentoResponse*)p = *(_ns1__aggiungiDocumentoAlProcedimentoResponse*)q;
}

void _ns1__aggiungiDocumentoAlProcedimento::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::token);
	soap_default_LONG64(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::idAmministrazione);
	soap_default_LONG64(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::idAoo);
	soap_default_string(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::idProcedimento);
	soap_default_string(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::nomeDocumento);
	soap_default_string(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::nomeFile);
	this->_ns1__aggiungiDocumentoAlProcedimento::__sizemetaDatiDocumento = 0;
	this->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento = NULL;
	soap_default_bool(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::inAllegato);
	/* transient soap skipped */
}

void _ns1__aggiungiDocumentoAlProcedimento::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::token);
	soap_serialize_string(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::idProcedimento);
	soap_serialize_string(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::nomeDocumento);
	soap_serialize_string(soap, &this->_ns1__aggiungiDocumentoAlProcedimento::nomeFile);
	if (this->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento)
	{	int i;
		for (i = 0; i < this->_ns1__aggiungiDocumentoAlProcedimento::__sizemetaDatiDocumento; i++)
		{
			soap_serialize_PointerTons1__MetaDato(soap, this->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__aggiungiDocumentoAlProcedimento::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__aggiungiDocumentoAlProcedimento(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, const char *tag, int id, const _ns1__aggiungiDocumentoAlProcedimento *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento), type))
		return soap->error;
	if (a->_ns1__aggiungiDocumentoAlProcedimento::token)
	{	if (soap_out_string(soap, "ns1:token", -1, &a->_ns1__aggiungiDocumentoAlProcedimento::token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:token"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAmministrazione", -1, &(a->_ns1__aggiungiDocumentoAlProcedimento::idAmministrazione), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAoo", -1, &(a->_ns1__aggiungiDocumentoAlProcedimento::idAoo), ""))
		return soap->error;
	if (a->_ns1__aggiungiDocumentoAlProcedimento::idProcedimento)
	{	if (soap_out_string(soap, "ns1:idProcedimento", -1, &a->_ns1__aggiungiDocumentoAlProcedimento::idProcedimento, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:idProcedimento"))
		return soap->error;
	if (a->_ns1__aggiungiDocumentoAlProcedimento::nomeDocumento)
	{	if (soap_out_string(soap, "ns1:nomeDocumento", -1, &a->_ns1__aggiungiDocumentoAlProcedimento::nomeDocumento, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:nomeDocumento"))
		return soap->error;
	if (a->_ns1__aggiungiDocumentoAlProcedimento::nomeFile)
	{	if (soap_out_string(soap, "ns1:nomeFile", -1, &a->_ns1__aggiungiDocumentoAlProcedimento::nomeFile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:nomeFile"))
		return soap->error;
	if (a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento)
	{	int i;
		for (i = 0; i < a->_ns1__aggiungiDocumentoAlProcedimento::__sizemetaDatiDocumento; i++)
			if (soap_out_PointerTons1__MetaDato(soap, "ns1:metaDatiDocumento", -1, a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento + i, ""))
				return soap->error;
	}
	if (soap_out_bool(soap, "ns1:inAllegato", -1, &(a->_ns1__aggiungiDocumentoAlProcedimento::inAllegato), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__aggiungiDocumentoAlProcedimento::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__aggiungiDocumentoAlProcedimento(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__aggiungiDocumentoAlProcedimento * SOAP_FMAC4 soap_in__ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, const char *tag, _ns1__aggiungiDocumentoAlProcedimento *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__aggiungiDocumentoAlProcedimento *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento, sizeof(_ns1__aggiungiDocumentoAlProcedimento), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__aggiungiDocumentoAlProcedimento *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	size_t soap_flag_idAmministrazione1 = 1;
	size_t soap_flag_idAoo1 = 1;
	size_t soap_flag_idProcedimento1 = 1;
	size_t soap_flag_nomeDocumento1 = 1;
	size_t soap_flag_nomeFile1 = 1;
	struct soap_blist *soap_blist_metaDatiDocumento1 = NULL;
	size_t soap_flag_inAllegato1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &(a->_ns1__aggiungiDocumentoAlProcedimento::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_idAmministrazione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAmministrazione", &(a->_ns1__aggiungiDocumentoAlProcedimento::idAmministrazione), "xsd:long"))
				{	soap_flag_idAmministrazione1--;
					continue;
				}
			if (soap_flag_idAoo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAoo", &(a->_ns1__aggiungiDocumentoAlProcedimento::idAoo), "xsd:long"))
				{	soap_flag_idAoo1--;
					continue;
				}
			if (soap_flag_idProcedimento1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:idProcedimento", &(a->_ns1__aggiungiDocumentoAlProcedimento::idProcedimento), "xsd:string"))
				{	soap_flag_idProcedimento1--;
					continue;
				}
			if (soap_flag_nomeDocumento1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nomeDocumento", &(a->_ns1__aggiungiDocumentoAlProcedimento::nomeDocumento), "xsd:string"))
				{	soap_flag_nomeDocumento1--;
					continue;
				}
			if (soap_flag_nomeFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nomeFile", &(a->_ns1__aggiungiDocumentoAlProcedimento::nomeFile), "xsd:string"))
				{	soap_flag_nomeFile1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:metaDatiDocumento", 1, NULL))
			{	if (a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento == NULL)
				{	if (soap_blist_metaDatiDocumento1 == NULL)
						soap_blist_metaDatiDocumento1 = soap_new_block(soap);
					a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento = (ns1__MetaDato **)soap_push_block(soap, soap_blist_metaDatiDocumento1, sizeof(ns1__MetaDato *));
					if (a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento == NULL)
						return NULL;
					*a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__MetaDato(soap, "ns1:metaDatiDocumento", a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento, "ns1:MetaDato"))
				{	a->_ns1__aggiungiDocumentoAlProcedimento::__sizemetaDatiDocumento++;
					a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento = NULL;
					continue;
				}
			}
			if (soap_flag_inAllegato1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:inAllegato", &(a->_ns1__aggiungiDocumentoAlProcedimento::inAllegato), "xsd:boolean"))
				{	soap_flag_inAllegato1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento)
			soap_pop_block(soap, soap_blist_metaDatiDocumento1);
		if (a->_ns1__aggiungiDocumentoAlProcedimento::__sizemetaDatiDocumento)
			a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento = (ns1__MetaDato **)soap_save_block(soap, soap_blist_metaDatiDocumento1, NULL, 1);
		else
		{	a->_ns1__aggiungiDocumentoAlProcedimento::metaDatiDocumento = NULL;
			if (soap_blist_metaDatiDocumento1)
				soap_end_block(soap, soap_blist_metaDatiDocumento1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__aggiungiDocumentoAlProcedimento *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento, 0, sizeof(_ns1__aggiungiDocumentoAlProcedimento), 0, soap_copy__ns1__aggiungiDocumentoAlProcedimento);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token1 > 0 || soap_flag_idAmministrazione1 > 0 || soap_flag_idAoo1 > 0 || soap_flag_idProcedimento1 > 0 || soap_flag_nomeDocumento1 > 0 || soap_flag_nomeFile1 > 0 || a->_ns1__aggiungiDocumentoAlProcedimento::__sizemetaDatiDocumento < 1 || soap_flag_inAllegato1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__aggiungiDocumentoAlProcedimento::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento);
	if (this->soap_out(soap, tag?tag:"ns1:aggiungiDocumentoAlProcedimento", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__aggiungiDocumentoAlProcedimento::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__aggiungiDocumentoAlProcedimento(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__aggiungiDocumentoAlProcedimento * SOAP_FMAC4 soap_get__ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, _ns1__aggiungiDocumentoAlProcedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__aggiungiDocumentoAlProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__aggiungiDocumentoAlProcedimento * SOAP_FMAC2 soap_instantiate__ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__aggiungiDocumentoAlProcedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__aggiungiDocumentoAlProcedimento);
		if (size)
			*size = sizeof(_ns1__aggiungiDocumentoAlProcedimento);
		((_ns1__aggiungiDocumentoAlProcedimento*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__aggiungiDocumentoAlProcedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__aggiungiDocumentoAlProcedimento);
		for (int i = 0; i < n; i++)
			((_ns1__aggiungiDocumentoAlProcedimento*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__aggiungiDocumentoAlProcedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__aggiungiDocumentoAlProcedimento %p -> %p\n", q, p));
	*(_ns1__aggiungiDocumentoAlProcedimento*)p = *(_ns1__aggiungiDocumentoAlProcedimento*)q;
}

void _ns1__attivaProcedimentoWideResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__attivaProcedimentoWideResponse::attivaProcedimentoWideReturn = NULL;
	/* transient soap skipped */
}

void _ns1__attivaProcedimentoWideResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Procedimento(soap, &this->_ns1__attivaProcedimentoWideResponse::attivaProcedimentoWideReturn);
	/* transient soap skipped */
}

int _ns1__attivaProcedimentoWideResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__attivaProcedimentoWideResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__attivaProcedimentoWideResponse(struct soap *soap, const char *tag, int id, const _ns1__attivaProcedimentoWideResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__attivaProcedimentoWideResponse), type))
		return soap->error;
	if (a->attivaProcedimentoWideReturn)
		soap_element_result(soap, "ns1:attivaProcedimentoWideReturn");
	if (a->_ns1__attivaProcedimentoWideResponse::attivaProcedimentoWideReturn)
	{	if (soap_out_PointerTons1__Procedimento(soap, "ns1:attivaProcedimentoWideReturn", -1, &a->_ns1__attivaProcedimentoWideResponse::attivaProcedimentoWideReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:attivaProcedimentoWideReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__attivaProcedimentoWideResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__attivaProcedimentoWideResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoWideResponse * SOAP_FMAC4 soap_in__ns1__attivaProcedimentoWideResponse(struct soap *soap, const char *tag, _ns1__attivaProcedimentoWideResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__attivaProcedimentoWideResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__attivaProcedimentoWideResponse, sizeof(_ns1__attivaProcedimentoWideResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__attivaProcedimentoWideResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__attivaProcedimentoWideResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_attivaProcedimentoWideReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attivaProcedimentoWideReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Procedimento(soap, "ns1:attivaProcedimentoWideReturn", &(a->_ns1__attivaProcedimentoWideResponse::attivaProcedimentoWideReturn), "ns1:Procedimento"))
				{	soap_flag_attivaProcedimentoWideReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:attivaProcedimentoWideReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__attivaProcedimentoWideResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__attivaProcedimentoWideResponse, 0, sizeof(_ns1__attivaProcedimentoWideResponse), 0, soap_copy__ns1__attivaProcedimentoWideResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_attivaProcedimentoWideReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__attivaProcedimentoWideResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__attivaProcedimentoWideResponse);
	if (this->soap_out(soap, tag?tag:"ns1:attivaProcedimentoWideResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__attivaProcedimentoWideResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__attivaProcedimentoWideResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoWideResponse * SOAP_FMAC4 soap_get__ns1__attivaProcedimentoWideResponse(struct soap *soap, _ns1__attivaProcedimentoWideResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__attivaProcedimentoWideResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__attivaProcedimentoWideResponse * SOAP_FMAC2 soap_instantiate__ns1__attivaProcedimentoWideResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__attivaProcedimentoWideResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__attivaProcedimentoWideResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__attivaProcedimentoWideResponse);
		if (size)
			*size = sizeof(_ns1__attivaProcedimentoWideResponse);
		((_ns1__attivaProcedimentoWideResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__attivaProcedimentoWideResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__attivaProcedimentoWideResponse);
		for (int i = 0; i < n; i++)
			((_ns1__attivaProcedimentoWideResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__attivaProcedimentoWideResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__attivaProcedimentoWideResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__attivaProcedimentoWideResponse %p -> %p\n", q, p));
	*(_ns1__attivaProcedimentoWideResponse*)p = *(_ns1__attivaProcedimentoWideResponse*)q;
}

void _ns1__attivaProcedimentoWide::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__attivaProcedimentoWide::token);
	soap_default_string(soap, &this->_ns1__attivaProcedimentoWide::username);
	soap_default_LONG64(soap, &this->_ns1__attivaProcedimentoWide::idAmministrazione);
	soap_default_LONG64(soap, &this->_ns1__attivaProcedimentoWide::idAoo);
	soap_default_string(soap, &this->_ns1__attivaProcedimentoWide::codFlusso);
	soap_default_LONG64(soap, &this->_ns1__attivaProcedimentoWide::idFascicoloWide);
	soap_default_LONG64(soap, &this->_ns1__attivaProcedimentoWide::idDocumentoWide);
	/* transient soap skipped */
}

void _ns1__attivaProcedimentoWide::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__attivaProcedimentoWide::token);
	soap_serialize_string(soap, &this->_ns1__attivaProcedimentoWide::username);
	soap_serialize_string(soap, &this->_ns1__attivaProcedimentoWide::codFlusso);
	/* transient soap skipped */
}

int _ns1__attivaProcedimentoWide::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__attivaProcedimentoWide(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__attivaProcedimentoWide(struct soap *soap, const char *tag, int id, const _ns1__attivaProcedimentoWide *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__attivaProcedimentoWide), type))
		return soap->error;
	if (a->_ns1__attivaProcedimentoWide::token)
	{	if (soap_out_string(soap, "ns1:token", -1, &a->_ns1__attivaProcedimentoWide::token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:token"))
		return soap->error;
	if (a->_ns1__attivaProcedimentoWide::username)
	{	if (soap_out_string(soap, "ns1:username", -1, &a->_ns1__attivaProcedimentoWide::username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:username"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAmministrazione", -1, &(a->_ns1__attivaProcedimentoWide::idAmministrazione), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAoo", -1, &(a->_ns1__attivaProcedimentoWide::idAoo), ""))
		return soap->error;
	if (a->_ns1__attivaProcedimentoWide::codFlusso)
	{	if (soap_out_string(soap, "ns1:codFlusso", -1, &a->_ns1__attivaProcedimentoWide::codFlusso, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:codFlusso"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idFascicoloWide", -1, &(a->_ns1__attivaProcedimentoWide::idFascicoloWide), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idDocumentoWide", -1, &(a->_ns1__attivaProcedimentoWide::idDocumentoWide), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__attivaProcedimentoWide::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__attivaProcedimentoWide(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoWide * SOAP_FMAC4 soap_in__ns1__attivaProcedimentoWide(struct soap *soap, const char *tag, _ns1__attivaProcedimentoWide *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__attivaProcedimentoWide *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__attivaProcedimentoWide, sizeof(_ns1__attivaProcedimentoWide), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__attivaProcedimentoWide)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__attivaProcedimentoWide *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_idAmministrazione1 = 1;
	size_t soap_flag_idAoo1 = 1;
	size_t soap_flag_codFlusso1 = 1;
	size_t soap_flag_idFascicoloWide1 = 1;
	size_t soap_flag_idDocumentoWide1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &(a->_ns1__attivaProcedimentoWide::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__attivaProcedimentoWide::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_idAmministrazione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAmministrazione", &(a->_ns1__attivaProcedimentoWide::idAmministrazione), "xsd:long"))
				{	soap_flag_idAmministrazione1--;
					continue;
				}
			if (soap_flag_idAoo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAoo", &(a->_ns1__attivaProcedimentoWide::idAoo), "xsd:long"))
				{	soap_flag_idAoo1--;
					continue;
				}
			if (soap_flag_codFlusso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:codFlusso", &(a->_ns1__attivaProcedimentoWide::codFlusso), "xsd:string"))
				{	soap_flag_codFlusso1--;
					continue;
				}
			if (soap_flag_idFascicoloWide1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idFascicoloWide", &(a->_ns1__attivaProcedimentoWide::idFascicoloWide), "xsd:long"))
				{	soap_flag_idFascicoloWide1--;
					continue;
				}
			if (soap_flag_idDocumentoWide1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idDocumentoWide", &(a->_ns1__attivaProcedimentoWide::idDocumentoWide), "xsd:long"))
				{	soap_flag_idDocumentoWide1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__attivaProcedimentoWide *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__attivaProcedimentoWide, 0, sizeof(_ns1__attivaProcedimentoWide), 0, soap_copy__ns1__attivaProcedimentoWide);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token1 > 0 || soap_flag_username1 > 0 || soap_flag_idAmministrazione1 > 0 || soap_flag_idAoo1 > 0 || soap_flag_codFlusso1 > 0 || soap_flag_idFascicoloWide1 > 0 || soap_flag_idDocumentoWide1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__attivaProcedimentoWide::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__attivaProcedimentoWide);
	if (this->soap_out(soap, tag?tag:"ns1:attivaProcedimentoWide", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__attivaProcedimentoWide::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__attivaProcedimentoWide(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoWide * SOAP_FMAC4 soap_get__ns1__attivaProcedimentoWide(struct soap *soap, _ns1__attivaProcedimentoWide *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__attivaProcedimentoWide(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__attivaProcedimentoWide * SOAP_FMAC2 soap_instantiate__ns1__attivaProcedimentoWide(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__attivaProcedimentoWide(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__attivaProcedimentoWide, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__attivaProcedimentoWide);
		if (size)
			*size = sizeof(_ns1__attivaProcedimentoWide);
		((_ns1__attivaProcedimentoWide*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__attivaProcedimentoWide[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__attivaProcedimentoWide);
		for (int i = 0; i < n; i++)
			((_ns1__attivaProcedimentoWide*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__attivaProcedimentoWide*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__attivaProcedimentoWide(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__attivaProcedimentoWide %p -> %p\n", q, p));
	*(_ns1__attivaProcedimentoWide*)p = *(_ns1__attivaProcedimentoWide*)q;
}

void _ns1__attivaProcedimentoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__attivaProcedimentoResponse::attivaProcedimentoReturn = NULL;
	/* transient soap skipped */
}

void _ns1__attivaProcedimentoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Procedimento(soap, &this->_ns1__attivaProcedimentoResponse::attivaProcedimentoReturn);
	/* transient soap skipped */
}

int _ns1__attivaProcedimentoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__attivaProcedimentoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__attivaProcedimentoResponse(struct soap *soap, const char *tag, int id, const _ns1__attivaProcedimentoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__attivaProcedimentoResponse), type))
		return soap->error;
	if (a->attivaProcedimentoReturn)
		soap_element_result(soap, "ns1:attivaProcedimentoReturn");
	if (a->_ns1__attivaProcedimentoResponse::attivaProcedimentoReturn)
	{	if (soap_out_PointerTons1__Procedimento(soap, "ns1:attivaProcedimentoReturn", -1, &a->_ns1__attivaProcedimentoResponse::attivaProcedimentoReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:attivaProcedimentoReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__attivaProcedimentoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__attivaProcedimentoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoResponse * SOAP_FMAC4 soap_in__ns1__attivaProcedimentoResponse(struct soap *soap, const char *tag, _ns1__attivaProcedimentoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__attivaProcedimentoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__attivaProcedimentoResponse, sizeof(_ns1__attivaProcedimentoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__attivaProcedimentoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__attivaProcedimentoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_attivaProcedimentoReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attivaProcedimentoReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Procedimento(soap, "ns1:attivaProcedimentoReturn", &(a->_ns1__attivaProcedimentoResponse::attivaProcedimentoReturn), "ns1:Procedimento"))
				{	soap_flag_attivaProcedimentoReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:attivaProcedimentoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__attivaProcedimentoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__attivaProcedimentoResponse, 0, sizeof(_ns1__attivaProcedimentoResponse), 0, soap_copy__ns1__attivaProcedimentoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_attivaProcedimentoReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__attivaProcedimentoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__attivaProcedimentoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:attivaProcedimentoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__attivaProcedimentoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__attivaProcedimentoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoResponse * SOAP_FMAC4 soap_get__ns1__attivaProcedimentoResponse(struct soap *soap, _ns1__attivaProcedimentoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__attivaProcedimentoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__attivaProcedimentoResponse * SOAP_FMAC2 soap_instantiate__ns1__attivaProcedimentoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__attivaProcedimentoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__attivaProcedimentoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__attivaProcedimentoResponse);
		if (size)
			*size = sizeof(_ns1__attivaProcedimentoResponse);
		((_ns1__attivaProcedimentoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__attivaProcedimentoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__attivaProcedimentoResponse);
		for (int i = 0; i < n; i++)
			((_ns1__attivaProcedimentoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__attivaProcedimentoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__attivaProcedimentoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__attivaProcedimentoResponse %p -> %p\n", q, p));
	*(_ns1__attivaProcedimentoResponse*)p = *(_ns1__attivaProcedimentoResponse*)q;
}

void _ns1__attivaProcedimento::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__attivaProcedimento::token);
	soap_default_string(soap, &this->_ns1__attivaProcedimento::username);
	soap_default_LONG64(soap, &this->_ns1__attivaProcedimento::idAmministrazione);
	soap_default_LONG64(soap, &this->_ns1__attivaProcedimento::idAoo);
	soap_default_string(soap, &this->_ns1__attivaProcedimento::codFlusso);
	soap_default_string(soap, &this->_ns1__attivaProcedimento::nomeDocumento);
	soap_default_string(soap, &this->_ns1__attivaProcedimento::nomeFile);
	this->_ns1__attivaProcedimento::__sizemetaDatiDocumento = 0;
	this->_ns1__attivaProcedimento::metaDatiDocumento = NULL;
	this->_ns1__attivaProcedimento::__sizemetaDatiProcedimento = 0;
	this->_ns1__attivaProcedimento::metaDatiProcedimento = NULL;
	/* transient soap skipped */
}

void _ns1__attivaProcedimento::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__attivaProcedimento::token);
	soap_serialize_string(soap, &this->_ns1__attivaProcedimento::username);
	soap_serialize_string(soap, &this->_ns1__attivaProcedimento::codFlusso);
	soap_serialize_string(soap, &this->_ns1__attivaProcedimento::nomeDocumento);
	soap_serialize_string(soap, &this->_ns1__attivaProcedimento::nomeFile);
	if (this->_ns1__attivaProcedimento::metaDatiDocumento)
	{	int i;
		for (i = 0; i < this->_ns1__attivaProcedimento::__sizemetaDatiDocumento; i++)
		{
			soap_serialize_PointerTons1__MetaDato(soap, this->_ns1__attivaProcedimento::metaDatiDocumento + i);
		}
	}
	if (this->_ns1__attivaProcedimento::metaDatiProcedimento)
	{	int i;
		for (i = 0; i < this->_ns1__attivaProcedimento::__sizemetaDatiProcedimento; i++)
		{
			soap_serialize_PointerTons1__MetaDato(soap, this->_ns1__attivaProcedimento::metaDatiProcedimento + i);
		}
	}
	/* transient soap skipped */
}

int _ns1__attivaProcedimento::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__attivaProcedimento(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__attivaProcedimento(struct soap *soap, const char *tag, int id, const _ns1__attivaProcedimento *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__attivaProcedimento), type))
		return soap->error;
	if (a->_ns1__attivaProcedimento::token)
	{	if (soap_out_string(soap, "ns1:token", -1, &a->_ns1__attivaProcedimento::token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:token"))
		return soap->error;
	if (a->_ns1__attivaProcedimento::username)
	{	if (soap_out_string(soap, "ns1:username", -1, &a->_ns1__attivaProcedimento::username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:username"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAmministrazione", -1, &(a->_ns1__attivaProcedimento::idAmministrazione), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAoo", -1, &(a->_ns1__attivaProcedimento::idAoo), ""))
		return soap->error;
	if (a->_ns1__attivaProcedimento::codFlusso)
	{	if (soap_out_string(soap, "ns1:codFlusso", -1, &a->_ns1__attivaProcedimento::codFlusso, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:codFlusso"))
		return soap->error;
	if (a->_ns1__attivaProcedimento::nomeDocumento)
	{	if (soap_out_string(soap, "ns1:nomeDocumento", -1, &a->_ns1__attivaProcedimento::nomeDocumento, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:nomeDocumento"))
		return soap->error;
	if (a->_ns1__attivaProcedimento::nomeFile)
	{	if (soap_out_string(soap, "ns1:nomeFile", -1, &a->_ns1__attivaProcedimento::nomeFile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:nomeFile"))
		return soap->error;
	if (a->_ns1__attivaProcedimento::metaDatiDocumento)
	{	int i;
		for (i = 0; i < a->_ns1__attivaProcedimento::__sizemetaDatiDocumento; i++)
			if (soap_out_PointerTons1__MetaDato(soap, "ns1:metaDatiDocumento", -1, a->_ns1__attivaProcedimento::metaDatiDocumento + i, ""))
				return soap->error;
	}
	if (a->_ns1__attivaProcedimento::metaDatiProcedimento)
	{	int i;
		for (i = 0; i < a->_ns1__attivaProcedimento::__sizemetaDatiProcedimento; i++)
			if (soap_out_PointerTons1__MetaDato(soap, "ns1:metaDatiProcedimento", -1, a->_ns1__attivaProcedimento::metaDatiProcedimento + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__attivaProcedimento::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__attivaProcedimento(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__attivaProcedimento * SOAP_FMAC4 soap_in__ns1__attivaProcedimento(struct soap *soap, const char *tag, _ns1__attivaProcedimento *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__attivaProcedimento *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__attivaProcedimento, sizeof(_ns1__attivaProcedimento), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__attivaProcedimento)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__attivaProcedimento *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_idAmministrazione1 = 1;
	size_t soap_flag_idAoo1 = 1;
	size_t soap_flag_codFlusso1 = 1;
	size_t soap_flag_nomeDocumento1 = 1;
	size_t soap_flag_nomeFile1 = 1;
	struct soap_blist *soap_blist_metaDatiDocumento1 = NULL;
	struct soap_blist *soap_blist_metaDatiProcedimento1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &(a->_ns1__attivaProcedimento::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__attivaProcedimento::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_idAmministrazione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAmministrazione", &(a->_ns1__attivaProcedimento::idAmministrazione), "xsd:long"))
				{	soap_flag_idAmministrazione1--;
					continue;
				}
			if (soap_flag_idAoo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAoo", &(a->_ns1__attivaProcedimento::idAoo), "xsd:long"))
				{	soap_flag_idAoo1--;
					continue;
				}
			if (soap_flag_codFlusso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:codFlusso", &(a->_ns1__attivaProcedimento::codFlusso), "xsd:string"))
				{	soap_flag_codFlusso1--;
					continue;
				}
			if (soap_flag_nomeDocumento1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nomeDocumento", &(a->_ns1__attivaProcedimento::nomeDocumento), "xsd:string"))
				{	soap_flag_nomeDocumento1--;
					continue;
				}
			if (soap_flag_nomeFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nomeFile", &(a->_ns1__attivaProcedimento::nomeFile), "xsd:string"))
				{	soap_flag_nomeFile1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:metaDatiDocumento", 1, NULL))
			{	if (a->_ns1__attivaProcedimento::metaDatiDocumento == NULL)
				{	if (soap_blist_metaDatiDocumento1 == NULL)
						soap_blist_metaDatiDocumento1 = soap_new_block(soap);
					a->_ns1__attivaProcedimento::metaDatiDocumento = (ns1__MetaDato **)soap_push_block(soap, soap_blist_metaDatiDocumento1, sizeof(ns1__MetaDato *));
					if (a->_ns1__attivaProcedimento::metaDatiDocumento == NULL)
						return NULL;
					*a->_ns1__attivaProcedimento::metaDatiDocumento = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__MetaDato(soap, "ns1:metaDatiDocumento", a->_ns1__attivaProcedimento::metaDatiDocumento, "ns1:MetaDato"))
				{	a->_ns1__attivaProcedimento::__sizemetaDatiDocumento++;
					a->_ns1__attivaProcedimento::metaDatiDocumento = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:metaDatiProcedimento", 1, NULL))
			{	if (a->_ns1__attivaProcedimento::metaDatiProcedimento == NULL)
				{	if (soap_blist_metaDatiProcedimento1 == NULL)
						soap_blist_metaDatiProcedimento1 = soap_new_block(soap);
					a->_ns1__attivaProcedimento::metaDatiProcedimento = (ns1__MetaDato **)soap_push_block(soap, soap_blist_metaDatiProcedimento1, sizeof(ns1__MetaDato *));
					if (a->_ns1__attivaProcedimento::metaDatiProcedimento == NULL)
						return NULL;
					*a->_ns1__attivaProcedimento::metaDatiProcedimento = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__MetaDato(soap, "ns1:metaDatiProcedimento", a->_ns1__attivaProcedimento::metaDatiProcedimento, "ns1:MetaDato"))
				{	a->_ns1__attivaProcedimento::__sizemetaDatiProcedimento++;
					a->_ns1__attivaProcedimento::metaDatiProcedimento = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__attivaProcedimento::metaDatiDocumento)
			soap_pop_block(soap, soap_blist_metaDatiDocumento1);
		if (a->_ns1__attivaProcedimento::__sizemetaDatiDocumento)
			a->_ns1__attivaProcedimento::metaDatiDocumento = (ns1__MetaDato **)soap_save_block(soap, soap_blist_metaDatiDocumento1, NULL, 1);
		else
		{	a->_ns1__attivaProcedimento::metaDatiDocumento = NULL;
			if (soap_blist_metaDatiDocumento1)
				soap_end_block(soap, soap_blist_metaDatiDocumento1);
		}
		if (a->_ns1__attivaProcedimento::metaDatiProcedimento)
			soap_pop_block(soap, soap_blist_metaDatiProcedimento1);
		if (a->_ns1__attivaProcedimento::__sizemetaDatiProcedimento)
			a->_ns1__attivaProcedimento::metaDatiProcedimento = (ns1__MetaDato **)soap_save_block(soap, soap_blist_metaDatiProcedimento1, NULL, 1);
		else
		{	a->_ns1__attivaProcedimento::metaDatiProcedimento = NULL;
			if (soap_blist_metaDatiProcedimento1)
				soap_end_block(soap, soap_blist_metaDatiProcedimento1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__attivaProcedimento *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__attivaProcedimento, 0, sizeof(_ns1__attivaProcedimento), 0, soap_copy__ns1__attivaProcedimento);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token1 > 0 || soap_flag_username1 > 0 || soap_flag_idAmministrazione1 > 0 || soap_flag_idAoo1 > 0 || soap_flag_codFlusso1 > 0 || soap_flag_nomeDocumento1 > 0 || soap_flag_nomeFile1 > 0 || a->_ns1__attivaProcedimento::__sizemetaDatiDocumento < 1 || a->_ns1__attivaProcedimento::__sizemetaDatiProcedimento < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__attivaProcedimento::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__attivaProcedimento);
	if (this->soap_out(soap, tag?tag:"ns1:attivaProcedimento", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__attivaProcedimento::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__attivaProcedimento(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__attivaProcedimento * SOAP_FMAC4 soap_get__ns1__attivaProcedimento(struct soap *soap, _ns1__attivaProcedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__attivaProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__attivaProcedimento * SOAP_FMAC2 soap_instantiate__ns1__attivaProcedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__attivaProcedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__attivaProcedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__attivaProcedimento);
		if (size)
			*size = sizeof(_ns1__attivaProcedimento);
		((_ns1__attivaProcedimento*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__attivaProcedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__attivaProcedimento);
		for (int i = 0; i < n; i++)
			((_ns1__attivaProcedimento*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__attivaProcedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__attivaProcedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__attivaProcedimento %p -> %p\n", q, p));
	*(_ns1__attivaProcedimento*)p = *(_ns1__attivaProcedimento*)q;
}

void _ns1__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__loginResponse::loginReturn);
	/* transient soap skipped */
}

void _ns1__loginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__loginResponse::loginReturn);
	/* transient soap skipped */
}

int _ns1__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loginResponse(struct soap *soap, const char *tag, int id, const _ns1__loginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loginResponse), type))
		return soap->error;
	if (a->loginReturn)
		soap_element_result(soap, "ns1:loginReturn");
	if (a->_ns1__loginResponse::loginReturn)
	{	if (soap_out_string(soap, "ns1:loginReturn", -1, &a->_ns1__loginResponse::loginReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:loginReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_in__ns1__loginResponse(struct soap *soap, const char *tag, _ns1__loginResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__loginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__loginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loginReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:loginReturn", &(a->_ns1__loginResponse::loginReturn), "xsd:string"))
				{	soap_flag_loginReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:loginReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loginResponse, 0, sizeof(_ns1__loginResponse), 0, soap_copy__ns1__loginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loginReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__loginResponse);
	if (this->soap_out(soap, tag?tag:"ns1:loginResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_get__ns1__loginResponse(struct soap *soap, _ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__loginResponse * SOAP_FMAC2 soap_instantiate__ns1__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__loginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__loginResponse);
		if (size)
			*size = sizeof(_ns1__loginResponse);
		((_ns1__loginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__loginResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__loginResponse);
		for (int i = 0; i < n; i++)
			((_ns1__loginResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__loginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__loginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__loginResponse %p -> %p\n", q, p));
	*(_ns1__loginResponse*)p = *(_ns1__loginResponse*)q;
}

void _ns1__login::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__login::usrApp);
	soap_default_string(soap, &this->_ns1__login::pwdApp);
	/* transient soap skipped */
}

void _ns1__login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__login::usrApp);
	soap_serialize_string(soap, &this->_ns1__login::pwdApp);
	/* transient soap skipped */
}

int _ns1__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__login(struct soap *soap, const char *tag, int id, const _ns1__login *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__login), type))
		return soap->error;
	if (a->_ns1__login::usrApp)
	{	if (soap_out_string(soap, "ns1:usrApp", -1, &a->_ns1__login::usrApp, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:usrApp"))
		return soap->error;
	if (a->_ns1__login::pwdApp)
	{	if (soap_out_string(soap, "ns1:pwdApp", -1, &a->_ns1__login::pwdApp, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:pwdApp"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__login(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__login * SOAP_FMAC4 soap_in__ns1__login(struct soap *soap, const char *tag, _ns1__login *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__login, sizeof(_ns1__login), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__login)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__login *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_usrApp1 = 1;
	size_t soap_flag_pwdApp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_usrApp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:usrApp", &(a->_ns1__login::usrApp), "xsd:string"))
				{	soap_flag_usrApp1--;
					continue;
				}
			if (soap_flag_pwdApp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:pwdApp", &(a->_ns1__login::pwdApp), "xsd:string"))
				{	soap_flag_pwdApp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__login, 0, sizeof(_ns1__login), 0, soap_copy__ns1__login);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_usrApp1 > 0 || soap_flag_pwdApp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__login);
	if (this->soap_out(soap, tag?tag:"ns1:login", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__login(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__login * SOAP_FMAC4 soap_get__ns1__login(struct soap *soap, _ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__login * SOAP_FMAC2 soap_instantiate__ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__login);
		if (size)
			*size = sizeof(_ns1__login);
		((_ns1__login*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__login[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__login);
		for (int i = 0; i < n; i++)
			((_ns1__login*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__login %p -> %p\n", q, p));
	*(_ns1__login*)p = *(_ns1__login*)q;
}

void _ns1__getTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getTokenResponse::getTokenReturn);
	/* transient soap skipped */
}

void _ns1__getTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getTokenResponse::getTokenReturn);
	/* transient soap skipped */
}

int _ns1__getTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTokenResponse(struct soap *soap, const char *tag, int id, const _ns1__getTokenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTokenResponse), type))
		return soap->error;
	if (a->getTokenReturn)
		soap_element_result(soap, "ns1:getTokenReturn");
	if (a->_ns1__getTokenResponse::getTokenReturn)
	{	if (soap_out_string(soap, "ns1:getTokenReturn", -1, &a->_ns1__getTokenResponse::getTokenReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:getTokenReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getTokenResponse * SOAP_FMAC4 soap_in__ns1__getTokenResponse(struct soap *soap, const char *tag, _ns1__getTokenResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getTokenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTokenResponse, sizeof(_ns1__getTokenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getTokenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getTokenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getTokenReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getTokenReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:getTokenReturn", &(a->_ns1__getTokenResponse::getTokenReturn), "xsd:string"))
				{	soap_flag_getTokenReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:getTokenReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTokenResponse, 0, sizeof(_ns1__getTokenResponse), 0, soap_copy__ns1__getTokenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getTokenReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getTokenResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTokenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getTokenResponse * SOAP_FMAC4 soap_get__ns1__getTokenResponse(struct soap *soap, _ns1__getTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getTokenResponse * SOAP_FMAC2 soap_instantiate__ns1__getTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getTokenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getTokenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTokenResponse);
		if (size)
			*size = sizeof(_ns1__getTokenResponse);
		((_ns1__getTokenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getTokenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getTokenResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getTokenResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getTokenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getTokenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getTokenResponse %p -> %p\n", q, p));
	*(_ns1__getTokenResponse*)p = *(_ns1__getTokenResponse*)q;
}

void _ns1__getToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getToken::token);
	soap_default_string(soap, &this->_ns1__getToken::connectionIdMac);
	soap_default_LONG64(soap, &this->_ns1__getToken::idAmministrazione);
	/* transient soap skipped */
}

void _ns1__getToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__getToken::token);
	soap_serialize_string(soap, &this->_ns1__getToken::connectionIdMac);
	/* transient soap skipped */
}

int _ns1__getToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getToken(struct soap *soap, const char *tag, int id, const _ns1__getToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getToken), type))
		return soap->error;
	if (a->_ns1__getToken::token)
	{	if (soap_out_string(soap, "ns1:token", -1, &a->_ns1__getToken::token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:token"))
		return soap->error;
	if (a->_ns1__getToken::connectionIdMac)
	{	if (soap_out_string(soap, "ns1:connectionIdMac", -1, &a->_ns1__getToken::connectionIdMac, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:connectionIdMac"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idAmministrazione", -1, &(a->_ns1__getToken::idAmministrazione), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getToken(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getToken * SOAP_FMAC4 soap_in__ns1__getToken(struct soap *soap, const char *tag, _ns1__getToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getToken, sizeof(_ns1__getToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	size_t soap_flag_connectionIdMac1 = 1;
	size_t soap_flag_idAmministrazione1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:token", &(a->_ns1__getToken::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_connectionIdMac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:connectionIdMac", &(a->_ns1__getToken::connectionIdMac), "xsd:string"))
				{	soap_flag_connectionIdMac1--;
					continue;
				}
			if (soap_flag_idAmministrazione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idAmministrazione", &(a->_ns1__getToken::idAmministrazione), "xsd:long"))
				{	soap_flag_idAmministrazione1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getToken, 0, sizeof(_ns1__getToken), 0, soap_copy__ns1__getToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token1 > 0 || soap_flag_connectionIdMac1 > 0 || soap_flag_idAmministrazione1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__getToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getToken);
	if (this->soap_out(soap, tag?tag:"ns1:getToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getToken(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getToken * SOAP_FMAC4 soap_get__ns1__getToken(struct soap *soap, _ns1__getToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__getToken * SOAP_FMAC2 soap_instantiate__ns1__getToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getToken);
		if (size)
			*size = sizeof(_ns1__getToken);
		((_ns1__getToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__getToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getToken);
		for (int i = 0; i < n; i++)
			((_ns1__getToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getToken %p -> %p\n", q, p));
	*(_ns1__getToken*)p = *(_ns1__getToken*)q;
}

void ns1__Giustificativo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Giustificativo::anno);
	soap_default_string(soap, &this->ns1__Giustificativo::codiceFlusso);
	this->ns1__Giustificativo::dataOraFine = NULL;
	this->ns1__Giustificativo::dataOraInizio = NULL;
	soap_default_string(soap, &this->ns1__Giustificativo::esito);
	soap_default_LONG64(soap, &this->ns1__Giustificativo::idDocumento);
	soap_default_LONG64(soap, &this->ns1__Giustificativo::idFascicolo);
	soap_default_string(soap, &this->ns1__Giustificativo::mese);
	soap_default_string(soap, &this->ns1__Giustificativo::nominativo);
	soap_default_string(soap, &this->ns1__Giustificativo::username);
	/* transient soap skipped */
}

void ns1__Giustificativo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Giustificativo::anno);
	soap_serialize_string(soap, &this->ns1__Giustificativo::codiceFlusso);
	soap_serialize_PointerTotime(soap, &this->ns1__Giustificativo::dataOraFine);
	soap_serialize_PointerTotime(soap, &this->ns1__Giustificativo::dataOraInizio);
	soap_serialize_string(soap, &this->ns1__Giustificativo::esito);
	soap_serialize_string(soap, &this->ns1__Giustificativo::mese);
	soap_serialize_string(soap, &this->ns1__Giustificativo::nominativo);
	soap_serialize_string(soap, &this->ns1__Giustificativo::username);
	/* transient soap skipped */
}

int ns1__Giustificativo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Giustificativo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Giustificativo(struct soap *soap, const char *tag, int id, const ns1__Giustificativo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Giustificativo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:anno", -1, &(a->ns1__Giustificativo::anno), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:codiceFlusso", -1, &(a->ns1__Giustificativo::codiceFlusso), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOraFine", -1, &(a->ns1__Giustificativo::dataOraFine), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOraInizio", -1, &(a->ns1__Giustificativo::dataOraInizio), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:esito", -1, &(a->ns1__Giustificativo::esito), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idDocumento", -1, &(a->ns1__Giustificativo::idDocumento), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:idFascicolo", -1, &(a->ns1__Giustificativo::idFascicolo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:mese", -1, &(a->ns1__Giustificativo::mese), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:nominativo", -1, &(a->ns1__Giustificativo::nominativo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:username", -1, &(a->ns1__Giustificativo::username), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Giustificativo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Giustificativo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Giustificativo * SOAP_FMAC4 soap_in_ns1__Giustificativo(struct soap *soap, const char *tag, ns1__Giustificativo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Giustificativo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Giustificativo, sizeof(ns1__Giustificativo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Giustificativo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Giustificativo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_anno1 = 1;
	size_t soap_flag_codiceFlusso1 = 1;
	size_t soap_flag_dataOraFine1 = 1;
	size_t soap_flag_dataOraInizio1 = 1;
	size_t soap_flag_esito1 = 1;
	size_t soap_flag_idDocumento1 = 1;
	size_t soap_flag_idFascicolo1 = 1;
	size_t soap_flag_mese1 = 1;
	size_t soap_flag_nominativo1 = 1;
	size_t soap_flag_username1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_anno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:anno", &(a->ns1__Giustificativo::anno), "xsd:string"))
				{	soap_flag_anno1--;
					continue;
				}
			if (soap_flag_codiceFlusso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:codiceFlusso", &(a->ns1__Giustificativo::codiceFlusso), "xsd:string"))
				{	soap_flag_codiceFlusso1--;
					continue;
				}
			if (soap_flag_dataOraFine1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOraFine", &(a->ns1__Giustificativo::dataOraFine), "xsd:dateTime"))
				{	soap_flag_dataOraFine1--;
					continue;
				}
			if (soap_flag_dataOraInizio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOraInizio", &(a->ns1__Giustificativo::dataOraInizio), "xsd:dateTime"))
				{	soap_flag_dataOraInizio1--;
					continue;
				}
			if (soap_flag_esito1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:esito", &(a->ns1__Giustificativo::esito), "xsd:string"))
				{	soap_flag_esito1--;
					continue;
				}
			if (soap_flag_idDocumento1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idDocumento", &(a->ns1__Giustificativo::idDocumento), "xsd:long"))
				{	soap_flag_idDocumento1--;
					continue;
				}
			if (soap_flag_idFascicolo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:idFascicolo", &(a->ns1__Giustificativo::idFascicolo), "xsd:long"))
				{	soap_flag_idFascicolo1--;
					continue;
				}
			if (soap_flag_mese1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:mese", &(a->ns1__Giustificativo::mese), "xsd:string"))
				{	soap_flag_mese1--;
					continue;
				}
			if (soap_flag_nominativo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nominativo", &(a->ns1__Giustificativo::nominativo), "xsd:string"))
				{	soap_flag_nominativo1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->ns1__Giustificativo::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Giustificativo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Giustificativo, 0, sizeof(ns1__Giustificativo), 0, soap_copy_ns1__Giustificativo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idDocumento1 > 0 || soap_flag_idFascicolo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Giustificativo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Giustificativo);
	if (this->soap_out(soap, tag?tag:"ns1:Giustificativo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Giustificativo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Giustificativo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Giustificativo * SOAP_FMAC4 soap_get_ns1__Giustificativo(struct soap *soap, ns1__Giustificativo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Giustificativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Giustificativo * SOAP_FMAC2 soap_instantiate_ns1__Giustificativo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Giustificativo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Giustificativo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Giustificativo);
		if (size)
			*size = sizeof(ns1__Giustificativo);
		((ns1__Giustificativo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Giustificativo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Giustificativo);
		for (int i = 0; i < n; i++)
			((ns1__Giustificativo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Giustificativo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Giustificativo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Giustificativo %p -> %p\n", q, p));
	*(ns1__Giustificativo*)p = *(ns1__Giustificativo*)q;
}

void ns1__Flusso::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Flusso::codFlusso);
	soap_default_string(soap, &this->ns1__Flusso::descrizione);
	/* transient soap skipped */
}

void ns1__Flusso::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Flusso::codFlusso);
	soap_serialize_string(soap, &this->ns1__Flusso::descrizione);
	/* transient soap skipped */
}

int ns1__Flusso::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Flusso(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Flusso(struct soap *soap, const char *tag, int id, const ns1__Flusso *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Flusso), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:codFlusso", -1, &(a->ns1__Flusso::codFlusso), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:descrizione", -1, &(a->ns1__Flusso::descrizione), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Flusso::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Flusso(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Flusso * SOAP_FMAC4 soap_in_ns1__Flusso(struct soap *soap, const char *tag, ns1__Flusso *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Flusso *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Flusso, sizeof(ns1__Flusso), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Flusso)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Flusso *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_codFlusso1 = 1;
	size_t soap_flag_descrizione1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_codFlusso1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:codFlusso", &(a->ns1__Flusso::codFlusso), "xsd:string"))
				{	soap_flag_codFlusso1--;
					continue;
				}
			if (soap_flag_descrizione1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:descrizione", &(a->ns1__Flusso::descrizione), "xsd:string"))
				{	soap_flag_descrizione1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Flusso *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Flusso, 0, sizeof(ns1__Flusso), 0, soap_copy_ns1__Flusso);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Flusso::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Flusso);
	if (this->soap_out(soap, tag?tag:"ns1:Flusso", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Flusso::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Flusso(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Flusso * SOAP_FMAC4 soap_get_ns1__Flusso(struct soap *soap, ns1__Flusso *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Flusso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Flusso * SOAP_FMAC2 soap_instantiate_ns1__Flusso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Flusso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Flusso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Flusso);
		if (size)
			*size = sizeof(ns1__Flusso);
		((ns1__Flusso*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Flusso[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Flusso);
		for (int i = 0; i < n; i++)
			((ns1__Flusso*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Flusso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Flusso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Flusso %p -> %p\n", q, p));
	*(ns1__Flusso*)p = *(ns1__Flusso*)q;
}

void ns1__Procedimento::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Procedimento::dataOraFine = NULL;
	this->ns1__Procedimento::dataOraInizio = NULL;
	soap_default_string(soap, &this->ns1__Procedimento::descrizione);
	soap_default_string(soap, &this->ns1__Procedimento::descrizioneOwner);
	soap_default_string(soap, &this->ns1__Procedimento::id);
	this->ns1__Procedimento::note = NULL;
	soap_default_string(soap, &this->ns1__Procedimento::numeroRepertorio);
	soap_default_string(soap, &this->ns1__Procedimento::richiedente);
	this->ns1__Procedimento::stato = NULL;
	this->ns1__Procedimento::step = NULL;
	this->ns1__Procedimento::stepCompetenza = NULL;
	soap_default_string(soap, &this->ns1__Procedimento::usernameOwner);
	/* transient soap skipped */
}

void ns1__Procedimento::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__Procedimento::dataOraFine);
	soap_serialize_PointerTotime(soap, &this->ns1__Procedimento::dataOraInizio);
	soap_serialize_string(soap, &this->ns1__Procedimento::descrizione);
	soap_serialize_string(soap, &this->ns1__Procedimento::descrizioneOwner);
	soap_serialize_string(soap, &this->ns1__Procedimento::id);
	soap_serialize_PointerTons1__ArrayOfNota(soap, &this->ns1__Procedimento::note);
	soap_serialize_string(soap, &this->ns1__Procedimento::numeroRepertorio);
	soap_serialize_string(soap, &this->ns1__Procedimento::richiedente);
	soap_serialize_PointerTons1__Stato(soap, &this->ns1__Procedimento::stato);
	soap_serialize_PointerTons1__ArrayOfStep(soap, &this->ns1__Procedimento::step);
	soap_serialize_PointerTons1__ArrayOfStepCompetenza(soap, &this->ns1__Procedimento::stepCompetenza);
	soap_serialize_string(soap, &this->ns1__Procedimento::usernameOwner);
	/* transient soap skipped */
}

int ns1__Procedimento::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Procedimento(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Procedimento(struct soap *soap, const char *tag, int id, const ns1__Procedimento *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Procedimento), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOraFine", -1, &(a->ns1__Procedimento::dataOraFine), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOraInizio", -1, &(a->ns1__Procedimento::dataOraInizio), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:descrizione", -1, &(a->ns1__Procedimento::descrizione), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:descrizioneOwner", -1, &(a->ns1__Procedimento::descrizioneOwner), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &(a->ns1__Procedimento::id), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfNota(soap, "ns1:note", -1, &(a->ns1__Procedimento::note), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:numeroRepertorio", -1, &(a->ns1__Procedimento::numeroRepertorio), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:richiedente", -1, &(a->ns1__Procedimento::richiedente), ""))
		return soap->error;
	if (soap_out_PointerTons1__Stato(soap, "ns1:stato", -1, &(a->ns1__Procedimento::stato), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfStep(soap, "ns1:step", -1, &(a->ns1__Procedimento::step), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfStepCompetenza(soap, "ns1:stepCompetenza", -1, &(a->ns1__Procedimento::stepCompetenza), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:usernameOwner", -1, &(a->ns1__Procedimento::usernameOwner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Procedimento::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Procedimento(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Procedimento * SOAP_FMAC4 soap_in_ns1__Procedimento(struct soap *soap, const char *tag, ns1__Procedimento *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Procedimento *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Procedimento, sizeof(ns1__Procedimento), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Procedimento)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Procedimento *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dataOraFine1 = 1;
	size_t soap_flag_dataOraInizio1 = 1;
	size_t soap_flag_descrizione1 = 1;
	size_t soap_flag_descrizioneOwner1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_note1 = 1;
	size_t soap_flag_numeroRepertorio1 = 1;
	size_t soap_flag_richiedente1 = 1;
	size_t soap_flag_stato1 = 1;
	size_t soap_flag_step1 = 1;
	size_t soap_flag_stepCompetenza1 = 1;
	size_t soap_flag_usernameOwner1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dataOraFine1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOraFine", &(a->ns1__Procedimento::dataOraFine), "xsd:dateTime"))
				{	soap_flag_dataOraFine1--;
					continue;
				}
			if (soap_flag_dataOraInizio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOraInizio", &(a->ns1__Procedimento::dataOraInizio), "xsd:dateTime"))
				{	soap_flag_dataOraInizio1--;
					continue;
				}
			if (soap_flag_descrizione1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:descrizione", &(a->ns1__Procedimento::descrizione), "xsd:string"))
				{	soap_flag_descrizione1--;
					continue;
				}
			if (soap_flag_descrizioneOwner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:descrizioneOwner", &(a->ns1__Procedimento::descrizioneOwner), "xsd:string"))
				{	soap_flag_descrizioneOwner1--;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &(a->ns1__Procedimento::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_note1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfNota(soap, "ns1:note", &(a->ns1__Procedimento::note), "ns1:ArrayOfNota"))
				{	soap_flag_note1--;
					continue;
				}
			if (soap_flag_numeroRepertorio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:numeroRepertorio", &(a->ns1__Procedimento::numeroRepertorio), "xsd:string"))
				{	soap_flag_numeroRepertorio1--;
					continue;
				}
			if (soap_flag_richiedente1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:richiedente", &(a->ns1__Procedimento::richiedente), "xsd:string"))
				{	soap_flag_richiedente1--;
					continue;
				}
			if (soap_flag_stato1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Stato(soap, "ns1:stato", &(a->ns1__Procedimento::stato), "ns1:Stato"))
				{	soap_flag_stato1--;
					continue;
				}
			if (soap_flag_step1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfStep(soap, "ns1:step", &(a->ns1__Procedimento::step), "ns1:ArrayOfStep"))
				{	soap_flag_step1--;
					continue;
				}
			if (soap_flag_stepCompetenza1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfStepCompetenza(soap, "ns1:stepCompetenza", &(a->ns1__Procedimento::stepCompetenza), "ns1:ArrayOfStepCompetenza"))
				{	soap_flag_stepCompetenza1--;
					continue;
				}
			if (soap_flag_usernameOwner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:usernameOwner", &(a->ns1__Procedimento::usernameOwner), "xsd:string"))
				{	soap_flag_usernameOwner1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Procedimento *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Procedimento, 0, sizeof(ns1__Procedimento), 0, soap_copy_ns1__Procedimento);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Procedimento::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Procedimento);
	if (this->soap_out(soap, tag?tag:"ns1:Procedimento", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Procedimento::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Procedimento(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Procedimento * SOAP_FMAC4 soap_get_ns1__Procedimento(struct soap *soap, ns1__Procedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Procedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Procedimento * SOAP_FMAC2 soap_instantiate_ns1__Procedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Procedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Procedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Procedimento);
		if (size)
			*size = sizeof(ns1__Procedimento);
		((ns1__Procedimento*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Procedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Procedimento);
		for (int i = 0; i < n; i++)
			((ns1__Procedimento*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Procedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Procedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Procedimento %p -> %p\n", q, p));
	*(ns1__Procedimento*)p = *(ns1__Procedimento*)q;
}

void ns1__ArrayOfStepCompetenza::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfStepCompetenza::__sizeitem = 0;
	this->ns1__ArrayOfStepCompetenza::item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfStepCompetenza::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfStepCompetenza::item)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfStepCompetenza::__sizeitem; i++)
		{
			soap_serialize_PointerTons1__StepCompetenza(soap, this->ns1__ArrayOfStepCompetenza::item + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfStepCompetenza::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfStepCompetenza(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfStepCompetenza(struct soap *soap, const char *tag, int id, const ns1__ArrayOfStepCompetenza *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfStepCompetenza), type))
		return soap->error;
	if (a->ns1__ArrayOfStepCompetenza::item)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfStepCompetenza::__sizeitem; i++)
			if (soap_out_PointerTons1__StepCompetenza(soap, "ns1:item", -1, a->ns1__ArrayOfStepCompetenza::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfStepCompetenza::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfStepCompetenza(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfStepCompetenza * SOAP_FMAC4 soap_in_ns1__ArrayOfStepCompetenza(struct soap *soap, const char *tag, ns1__ArrayOfStepCompetenza *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfStepCompetenza *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfStepCompetenza, sizeof(ns1__ArrayOfStepCompetenza), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfStepCompetenza)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfStepCompetenza *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:item", 1, NULL))
			{	if (a->ns1__ArrayOfStepCompetenza::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->ns1__ArrayOfStepCompetenza::item = (ns1__StepCompetenza **)soap_push_block(soap, soap_blist_item1, sizeof(ns1__StepCompetenza *));
					if (a->ns1__ArrayOfStepCompetenza::item == NULL)
						return NULL;
					*a->ns1__ArrayOfStepCompetenza::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__StepCompetenza(soap, "ns1:item", a->ns1__ArrayOfStepCompetenza::item, "ns1:StepCompetenza"))
				{	a->ns1__ArrayOfStepCompetenza::__sizeitem++;
					a->ns1__ArrayOfStepCompetenza::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfStepCompetenza::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->ns1__ArrayOfStepCompetenza::__sizeitem)
			a->ns1__ArrayOfStepCompetenza::item = (ns1__StepCompetenza **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->ns1__ArrayOfStepCompetenza::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfStepCompetenza *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfStepCompetenza, 0, sizeof(ns1__ArrayOfStepCompetenza), 0, soap_copy_ns1__ArrayOfStepCompetenza);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfStepCompetenza::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfStepCompetenza);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfStepCompetenza", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfStepCompetenza::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfStepCompetenza(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfStepCompetenza * SOAP_FMAC4 soap_get_ns1__ArrayOfStepCompetenza(struct soap *soap, ns1__ArrayOfStepCompetenza *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfStepCompetenza(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfStepCompetenza * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfStepCompetenza(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfStepCompetenza(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfStepCompetenza, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfStepCompetenza);
		if (size)
			*size = sizeof(ns1__ArrayOfStepCompetenza);
		((ns1__ArrayOfStepCompetenza*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfStepCompetenza[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfStepCompetenza);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfStepCompetenza*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfStepCompetenza*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfStepCompetenza(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfStepCompetenza %p -> %p\n", q, p));
	*(ns1__ArrayOfStepCompetenza*)p = *(ns1__ArrayOfStepCompetenza*)q;
}

void ns1__StepCompetenza::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__StepCompetenza::codiciFunzione = NULL;
	this->ns1__StepCompetenza::esito = NULL;
	this->ns1__StepCompetenza::funzioni = NULL;
	this->ns1__Step::dataOraFine = NULL;
	this->ns1__Step::dataOraInizio = NULL;
	soap_default_string(soap, &this->ns1__Step::descrizione);
	soap_default_string(soap, &this->ns1__Step::esecutore);
	soap_default_string(soap, &this->ns1__Step::id);
	/* transient soap skipped */
}

void ns1__StepCompetenza::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, &this->ns1__StepCompetenza::codiciFunzione);
	soap_serialize_PointerTons1__Esito(soap, &this->ns1__StepCompetenza::esito);
	soap_serialize_PointerTons1__ArrayOfFunzione(soap, &this->ns1__StepCompetenza::funzioni);
	soap_serialize_PointerTotime(soap, &this->ns1__Step::dataOraFine);
	soap_serialize_PointerTotime(soap, &this->ns1__Step::dataOraInizio);
	soap_serialize_string(soap, &this->ns1__Step::descrizione);
	soap_serialize_string(soap, &this->ns1__Step::esecutore);
	soap_serialize_string(soap, &this->ns1__Step::id);
	/* transient soap skipped */
}

int ns1__StepCompetenza::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StepCompetenza(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StepCompetenza(struct soap *soap, const char *tag, int id, const ns1__StepCompetenza *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StepCompetenza), "ns1:StepCompetenza"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOraFine", -1, &(a->ns1__Step::dataOraFine), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOraInizio", -1, &(a->ns1__Step::dataOraInizio), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:descrizione", -1, &(a->ns1__Step::descrizione), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:esecutore", -1, &(a->ns1__Step::esecutore), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &(a->ns1__Step::id), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, "ns1:codiciFunzione", -1, &(a->ns1__StepCompetenza::codiciFunzione), ""))
		return soap->error;
	if (soap_out_PointerTons1__Esito(soap, "ns1:esito", -1, &(a->ns1__StepCompetenza::esito), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfFunzione(soap, "ns1:funzioni", -1, &(a->ns1__StepCompetenza::funzioni), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StepCompetenza::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StepCompetenza(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StepCompetenza * SOAP_FMAC4 soap_in_ns1__StepCompetenza(struct soap *soap, const char *tag, ns1__StepCompetenza *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StepCompetenza *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StepCompetenza, sizeof(ns1__StepCompetenza), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StepCompetenza)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StepCompetenza *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dataOraFine2 = 1;
	size_t soap_flag_dataOraInizio2 = 1;
	size_t soap_flag_descrizione2 = 1;
	size_t soap_flag_esecutore2 = 1;
	size_t soap_flag_id2 = 1;
	size_t soap_flag_codiciFunzione1 = 1;
	size_t soap_flag_esito1 = 1;
	size_t soap_flag_funzioni1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dataOraFine2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOraFine", &(a->ns1__Step::dataOraFine), "xsd:dateTime"))
				{	soap_flag_dataOraFine2--;
					continue;
				}
			if (soap_flag_dataOraInizio2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOraInizio", &(a->ns1__Step::dataOraInizio), "xsd:dateTime"))
				{	soap_flag_dataOraInizio2--;
					continue;
				}
			if (soap_flag_descrizione2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:descrizione", &(a->ns1__Step::descrizione), "xsd:string"))
				{	soap_flag_descrizione2--;
					continue;
				}
			if (soap_flag_esecutore2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:esecutore", &(a->ns1__Step::esecutore), "xsd:string"))
				{	soap_flag_esecutore2--;
					continue;
				}
			if (soap_flag_id2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &(a->ns1__Step::id), "xsd:string"))
				{	soap_flag_id2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_codiciFunzione1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, "ns1:codiciFunzione", &(a->ns1__StepCompetenza::codiciFunzione), "ns1:ArrayOf_xsd_string"))
				{	soap_flag_codiciFunzione1--;
					continue;
				}
			if (soap_flag_esito1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Esito(soap, "ns1:esito", &(a->ns1__StepCompetenza::esito), "ns1:Esito"))
				{	soap_flag_esito1--;
					continue;
				}
			if (soap_flag_funzioni1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfFunzione(soap, "ns1:funzioni", &(a->ns1__StepCompetenza::funzioni), "ns1:ArrayOfFunzione"))
				{	soap_flag_funzioni1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StepCompetenza *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StepCompetenza, 0, sizeof(ns1__StepCompetenza), 0, soap_copy_ns1__StepCompetenza);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__StepCompetenza::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StepCompetenza);
	if (this->soap_out(soap, tag?tag:"ns1:StepCompetenza", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StepCompetenza::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StepCompetenza(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StepCompetenza * SOAP_FMAC4 soap_get_ns1__StepCompetenza(struct soap *soap, ns1__StepCompetenza *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StepCompetenza(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__StepCompetenza * SOAP_FMAC2 soap_instantiate_ns1__StepCompetenza(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StepCompetenza(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StepCompetenza, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__StepCompetenza);
		if (size)
			*size = sizeof(ns1__StepCompetenza);
		((ns1__StepCompetenza*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__StepCompetenza[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StepCompetenza);
		for (int i = 0; i < n; i++)
			((ns1__StepCompetenza*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StepCompetenza*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StepCompetenza(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StepCompetenza %p -> %p\n", q, p));
	*(ns1__StepCompetenza*)p = *(ns1__StepCompetenza*)q;
}

void ns1__ArrayOfFunzione::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfFunzione::__sizeitem = 0;
	this->ns1__ArrayOfFunzione::item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfFunzione::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfFunzione::item)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfFunzione::__sizeitem; i++)
		{
			soap_serialize_PointerTons1__Funzione(soap, this->ns1__ArrayOfFunzione::item + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfFunzione::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfFunzione(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfFunzione(struct soap *soap, const char *tag, int id, const ns1__ArrayOfFunzione *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfFunzione), type))
		return soap->error;
	if (a->ns1__ArrayOfFunzione::item)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfFunzione::__sizeitem; i++)
			if (soap_out_PointerTons1__Funzione(soap, "ns1:item", -1, a->ns1__ArrayOfFunzione::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfFunzione::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfFunzione(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfFunzione * SOAP_FMAC4 soap_in_ns1__ArrayOfFunzione(struct soap *soap, const char *tag, ns1__ArrayOfFunzione *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfFunzione *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfFunzione, sizeof(ns1__ArrayOfFunzione), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfFunzione)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfFunzione *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:item", 1, NULL))
			{	if (a->ns1__ArrayOfFunzione::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->ns1__ArrayOfFunzione::item = (ns1__Funzione **)soap_push_block(soap, soap_blist_item1, sizeof(ns1__Funzione *));
					if (a->ns1__ArrayOfFunzione::item == NULL)
						return NULL;
					*a->ns1__ArrayOfFunzione::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Funzione(soap, "ns1:item", a->ns1__ArrayOfFunzione::item, "ns1:Funzione"))
				{	a->ns1__ArrayOfFunzione::__sizeitem++;
					a->ns1__ArrayOfFunzione::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfFunzione::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->ns1__ArrayOfFunzione::__sizeitem)
			a->ns1__ArrayOfFunzione::item = (ns1__Funzione **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->ns1__ArrayOfFunzione::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfFunzione *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfFunzione, 0, sizeof(ns1__ArrayOfFunzione), 0, soap_copy_ns1__ArrayOfFunzione);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfFunzione::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfFunzione);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfFunzione", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfFunzione::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfFunzione(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfFunzione * SOAP_FMAC4 soap_get_ns1__ArrayOfFunzione(struct soap *soap, ns1__ArrayOfFunzione *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfFunzione(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfFunzione * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfFunzione(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfFunzione(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfFunzione, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfFunzione);
		if (size)
			*size = sizeof(ns1__ArrayOfFunzione);
		((ns1__ArrayOfFunzione*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfFunzione[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfFunzione);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfFunzione*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfFunzione*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfFunzione(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfFunzione %p -> %p\n", q, p));
	*(ns1__ArrayOfFunzione*)p = *(ns1__ArrayOfFunzione*)q;
}

void ns1__Funzione::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Funzione::attributi = NULL;
	soap_default_string(soap, &this->ns1__Funzione::codice);
	/* transient soap skipped */
}

void ns1__Funzione::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfAttributo(soap, &this->ns1__Funzione::attributi);
	soap_serialize_string(soap, &this->ns1__Funzione::codice);
	/* transient soap skipped */
}

int ns1__Funzione::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Funzione(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Funzione(struct soap *soap, const char *tag, int id, const ns1__Funzione *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Funzione), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfAttributo(soap, "ns1:attributi", -1, &(a->ns1__Funzione::attributi), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:codice", -1, &(a->ns1__Funzione::codice), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Funzione::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Funzione(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Funzione * SOAP_FMAC4 soap_in_ns1__Funzione(struct soap *soap, const char *tag, ns1__Funzione *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Funzione *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Funzione, sizeof(ns1__Funzione), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Funzione)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Funzione *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_attributi1 = 1;
	size_t soap_flag_codice1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attributi1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAttributo(soap, "ns1:attributi", &(a->ns1__Funzione::attributi), "ns1:ArrayOfAttributo"))
				{	soap_flag_attributi1--;
					continue;
				}
			if (soap_flag_codice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:codice", &(a->ns1__Funzione::codice), "xsd:string"))
				{	soap_flag_codice1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Funzione *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Funzione, 0, sizeof(ns1__Funzione), 0, soap_copy_ns1__Funzione);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Funzione::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Funzione);
	if (this->soap_out(soap, tag?tag:"ns1:Funzione", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Funzione::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Funzione(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Funzione * SOAP_FMAC4 soap_get_ns1__Funzione(struct soap *soap, ns1__Funzione *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Funzione(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Funzione * SOAP_FMAC2 soap_instantiate_ns1__Funzione(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Funzione(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Funzione, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Funzione);
		if (size)
			*size = sizeof(ns1__Funzione);
		((ns1__Funzione*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Funzione[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Funzione);
		for (int i = 0; i < n; i++)
			((ns1__Funzione*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Funzione*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Funzione(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Funzione %p -> %p\n", q, p));
	*(ns1__Funzione*)p = *(ns1__Funzione*)q;
}

void ns1__ArrayOfAttributo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfAttributo::__sizeitem = 0;
	this->ns1__ArrayOfAttributo::item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfAttributo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfAttributo::item)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfAttributo::__sizeitem; i++)
		{
			soap_serialize_PointerTons1__Attributo(soap, this->ns1__ArrayOfAttributo::item + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfAttributo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfAttributo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfAttributo(struct soap *soap, const char *tag, int id, const ns1__ArrayOfAttributo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfAttributo), type))
		return soap->error;
	if (a->ns1__ArrayOfAttributo::item)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfAttributo::__sizeitem; i++)
			if (soap_out_PointerTons1__Attributo(soap, "ns1:item", -1, a->ns1__ArrayOfAttributo::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfAttributo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfAttributo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfAttributo * SOAP_FMAC4 soap_in_ns1__ArrayOfAttributo(struct soap *soap, const char *tag, ns1__ArrayOfAttributo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfAttributo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfAttributo, sizeof(ns1__ArrayOfAttributo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfAttributo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfAttributo *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:item", 1, NULL))
			{	if (a->ns1__ArrayOfAttributo::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->ns1__ArrayOfAttributo::item = (ns1__Attributo **)soap_push_block(soap, soap_blist_item1, sizeof(ns1__Attributo *));
					if (a->ns1__ArrayOfAttributo::item == NULL)
						return NULL;
					*a->ns1__ArrayOfAttributo::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Attributo(soap, "ns1:item", a->ns1__ArrayOfAttributo::item, "ns1:Attributo"))
				{	a->ns1__ArrayOfAttributo::__sizeitem++;
					a->ns1__ArrayOfAttributo::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfAttributo::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->ns1__ArrayOfAttributo::__sizeitem)
			a->ns1__ArrayOfAttributo::item = (ns1__Attributo **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->ns1__ArrayOfAttributo::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfAttributo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfAttributo, 0, sizeof(ns1__ArrayOfAttributo), 0, soap_copy_ns1__ArrayOfAttributo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfAttributo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfAttributo);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfAttributo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfAttributo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfAttributo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfAttributo * SOAP_FMAC4 soap_get_ns1__ArrayOfAttributo(struct soap *soap, ns1__ArrayOfAttributo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfAttributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfAttributo * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfAttributo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfAttributo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfAttributo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfAttributo);
		if (size)
			*size = sizeof(ns1__ArrayOfAttributo);
		((ns1__ArrayOfAttributo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfAttributo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfAttributo);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfAttributo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfAttributo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfAttributo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfAttributo %p -> %p\n", q, p));
	*(ns1__ArrayOfAttributo*)p = *(ns1__ArrayOfAttributo*)q;
}

void ns1__Attributo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Attributo::nome);
	soap_default_string(soap, &this->ns1__Attributo::valore);
	/* transient soap skipped */
}

void ns1__Attributo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Attributo::nome);
	soap_serialize_string(soap, &this->ns1__Attributo::valore);
	/* transient soap skipped */
}

int ns1__Attributo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Attributo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Attributo(struct soap *soap, const char *tag, int id, const ns1__Attributo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Attributo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:nome", -1, &(a->ns1__Attributo::nome), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:valore", -1, &(a->ns1__Attributo::valore), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Attributo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Attributo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Attributo * SOAP_FMAC4 soap_in_ns1__Attributo(struct soap *soap, const char *tag, ns1__Attributo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Attributo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Attributo, sizeof(ns1__Attributo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Attributo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Attributo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nome1 = 1;
	size_t soap_flag_valore1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nome1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nome", &(a->ns1__Attributo::nome), "xsd:string"))
				{	soap_flag_nome1--;
					continue;
				}
			if (soap_flag_valore1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:valore", &(a->ns1__Attributo::valore), "xsd:string"))
				{	soap_flag_valore1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Attributo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Attributo, 0, sizeof(ns1__Attributo), 0, soap_copy_ns1__Attributo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Attributo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Attributo);
	if (this->soap_out(soap, tag?tag:"ns1:Attributo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Attributo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Attributo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Attributo * SOAP_FMAC4 soap_get_ns1__Attributo(struct soap *soap, ns1__Attributo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Attributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Attributo * SOAP_FMAC2 soap_instantiate_ns1__Attributo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Attributo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Attributo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Attributo);
		if (size)
			*size = sizeof(ns1__Attributo);
		((ns1__Attributo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Attributo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Attributo);
		for (int i = 0; i < n; i++)
			((ns1__Attributo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Attributo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Attributo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Attributo %p -> %p\n", q, p));
	*(ns1__Attributo*)p = *(ns1__Attributo*)q;
}

void ns1__Esito::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Esito::descrizione);
	this->ns1__Esito::valori = NULL;
	/* transient soap skipped */
}

void ns1__Esito::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Esito::descrizione);
	soap_serialize_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, &this->ns1__Esito::valori);
	/* transient soap skipped */
}

int ns1__Esito::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Esito(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Esito(struct soap *soap, const char *tag, int id, const ns1__Esito *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Esito), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:descrizione", -1, &(a->ns1__Esito::descrizione), ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, "ns1:valori", -1, &(a->ns1__Esito::valori), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Esito::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Esito(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Esito * SOAP_FMAC4 soap_in_ns1__Esito(struct soap *soap, const char *tag, ns1__Esito *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Esito *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Esito, sizeof(ns1__Esito), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Esito)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Esito *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_descrizione1 = 1;
	size_t soap_flag_valori1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_descrizione1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:descrizione", &(a->ns1__Esito::descrizione), "xsd:string"))
				{	soap_flag_descrizione1--;
					continue;
				}
			if (soap_flag_valori1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, "ns1:valori", &(a->ns1__Esito::valori), "ns1:ArrayOf_xsd_string"))
				{	soap_flag_valori1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Esito *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Esito, 0, sizeof(ns1__Esito), 0, soap_copy_ns1__Esito);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Esito::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Esito);
	if (this->soap_out(soap, tag?tag:"ns1:Esito", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Esito::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Esito(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Esito * SOAP_FMAC4 soap_get_ns1__Esito(struct soap *soap, ns1__Esito *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Esito(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Esito * SOAP_FMAC2 soap_instantiate_ns1__Esito(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Esito(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Esito, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Esito);
		if (size)
			*size = sizeof(ns1__Esito);
		((ns1__Esito*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Esito[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Esito);
		for (int i = 0; i < n; i++)
			((ns1__Esito*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Esito*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Esito(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Esito %p -> %p\n", q, p));
	*(ns1__Esito*)p = *(ns1__Esito*)q;
}

void ns1__ArrayOf_USCORExsd_USCOREstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOf_USCORExsd_USCOREstring::__sizeitem = 0;
	this->ns1__ArrayOf_USCORExsd_USCOREstring::item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOf_USCORExsd_USCOREstring::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOf_USCORExsd_USCOREstring::item)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOf_USCORExsd_USCOREstring::__sizeitem; i++)
		{
			soap_serialize_string(soap, this->ns1__ArrayOf_USCORExsd_USCOREstring::item + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOf_USCORExsd_USCOREstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOf_USCORExsd_USCOREstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, const ns1__ArrayOf_USCORExsd_USCOREstring *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring), type))
		return soap->error;
	if (a->ns1__ArrayOf_USCORExsd_USCOREstring::item)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOf_USCORExsd_USCOREstring::__sizeitem; i++)
			if (soap_out_string(soap, "ns1:item", -1, a->ns1__ArrayOf_USCORExsd_USCOREstring::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOf_USCORExsd_USCOREstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOf_USCORExsd_USCOREstring(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_in_ns1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ns1__ArrayOf_USCORExsd_USCOREstring *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOf_USCORExsd_USCOREstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring, sizeof(ns1__ArrayOf_USCORExsd_USCOREstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOf_USCORExsd_USCOREstring *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:item", 1, NULL))
			{	if (a->ns1__ArrayOf_USCORExsd_USCOREstring::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->ns1__ArrayOf_USCORExsd_USCOREstring::item = (char **)soap_push_block(soap, soap_blist_item1, sizeof(char *));
					if (a->ns1__ArrayOf_USCORExsd_USCOREstring::item == NULL)
						return NULL;
					*a->ns1__ArrayOf_USCORExsd_USCOREstring::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns1:item", a->ns1__ArrayOf_USCORExsd_USCOREstring::item, "xsd:string"))
				{	a->ns1__ArrayOf_USCORExsd_USCOREstring::__sizeitem++;
					a->ns1__ArrayOf_USCORExsd_USCOREstring::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOf_USCORExsd_USCOREstring::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->ns1__ArrayOf_USCORExsd_USCOREstring::__sizeitem)
			a->ns1__ArrayOf_USCORExsd_USCOREstring::item = (char **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->ns1__ArrayOf_USCORExsd_USCOREstring::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOf_USCORExsd_USCOREstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring, 0, sizeof(ns1__ArrayOf_USCORExsd_USCOREstring), 0, soap_copy_ns1__ArrayOf_USCORExsd_USCOREstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOf_USCORExsd_USCOREstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOf_xsd_string", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOf_USCORExsd_USCOREstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOf_USCORExsd_USCOREstring(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_get_ns1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ns1__ArrayOf_USCORExsd_USCOREstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC2 soap_instantiate_ns1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOf_USCORExsd_USCOREstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOf_USCORExsd_USCOREstring);
		if (size)
			*size = sizeof(ns1__ArrayOf_USCORExsd_USCOREstring);
		((ns1__ArrayOf_USCORExsd_USCOREstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOf_USCORExsd_USCOREstring[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOf_USCORExsd_USCOREstring);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOf_USCORExsd_USCOREstring*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOf_USCORExsd_USCOREstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOf_USCORExsd_USCOREstring %p -> %p\n", q, p));
	*(ns1__ArrayOf_USCORExsd_USCOREstring*)p = *(ns1__ArrayOf_USCORExsd_USCOREstring*)q;
}

void ns1__ArrayOfStep::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfStep::__sizeitem = 0;
	this->ns1__ArrayOfStep::item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfStep::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfStep::item)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfStep::__sizeitem; i++)
		{
			soap_serialize_PointerTons1__Step(soap, this->ns1__ArrayOfStep::item + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfStep::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfStep(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfStep(struct soap *soap, const char *tag, int id, const ns1__ArrayOfStep *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfStep), type))
		return soap->error;
	if (a->ns1__ArrayOfStep::item)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfStep::__sizeitem; i++)
			if (soap_out_PointerTons1__Step(soap, "ns1:item", -1, a->ns1__ArrayOfStep::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfStep::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfStep(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfStep * SOAP_FMAC4 soap_in_ns1__ArrayOfStep(struct soap *soap, const char *tag, ns1__ArrayOfStep *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfStep *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfStep, sizeof(ns1__ArrayOfStep), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfStep)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfStep *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:item", 1, NULL))
			{	if (a->ns1__ArrayOfStep::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->ns1__ArrayOfStep::item = (ns1__Step **)soap_push_block(soap, soap_blist_item1, sizeof(ns1__Step *));
					if (a->ns1__ArrayOfStep::item == NULL)
						return NULL;
					*a->ns1__ArrayOfStep::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Step(soap, "ns1:item", a->ns1__ArrayOfStep::item, "ns1:Step"))
				{	a->ns1__ArrayOfStep::__sizeitem++;
					a->ns1__ArrayOfStep::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfStep::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->ns1__ArrayOfStep::__sizeitem)
			a->ns1__ArrayOfStep::item = (ns1__Step **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->ns1__ArrayOfStep::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfStep *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfStep, 0, sizeof(ns1__ArrayOfStep), 0, soap_copy_ns1__ArrayOfStep);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfStep::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfStep);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfStep", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfStep::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfStep(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfStep * SOAP_FMAC4 soap_get_ns1__ArrayOfStep(struct soap *soap, ns1__ArrayOfStep *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfStep * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfStep(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfStep(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfStep, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfStep);
		if (size)
			*size = sizeof(ns1__ArrayOfStep);
		((ns1__ArrayOfStep*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfStep[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfStep);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfStep*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfStep*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfStep(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfStep %p -> %p\n", q, p));
	*(ns1__ArrayOfStep*)p = *(ns1__ArrayOfStep*)q;
}

void ns1__Step::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Step::dataOraFine = NULL;
	this->ns1__Step::dataOraInizio = NULL;
	soap_default_string(soap, &this->ns1__Step::descrizione);
	soap_default_string(soap, &this->ns1__Step::esecutore);
	soap_default_string(soap, &this->ns1__Step::id);
	/* transient soap skipped */
}

void ns1__Step::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__Step::dataOraFine);
	soap_serialize_PointerTotime(soap, &this->ns1__Step::dataOraInizio);
	soap_serialize_string(soap, &this->ns1__Step::descrizione);
	soap_serialize_string(soap, &this->ns1__Step::esecutore);
	soap_serialize_string(soap, &this->ns1__Step::id);
	/* transient soap skipped */
}

int ns1__Step::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Step(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Step(struct soap *soap, const char *tag, int id, const ns1__Step *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Step), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOraFine", -1, &(a->ns1__Step::dataOraFine), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOraInizio", -1, &(a->ns1__Step::dataOraInizio), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:descrizione", -1, &(a->ns1__Step::descrizione), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:esecutore", -1, &(a->ns1__Step::esecutore), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:id", -1, &(a->ns1__Step::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Step::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Step(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Step * SOAP_FMAC4 soap_in_ns1__Step(struct soap *soap, const char *tag, ns1__Step *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Step *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Step, sizeof(ns1__Step), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Step)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Step *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dataOraFine1 = 1;
	size_t soap_flag_dataOraInizio1 = 1;
	size_t soap_flag_descrizione1 = 1;
	size_t soap_flag_esecutore1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dataOraFine1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOraFine", &(a->ns1__Step::dataOraFine), "xsd:dateTime"))
				{	soap_flag_dataOraFine1--;
					continue;
				}
			if (soap_flag_dataOraInizio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOraInizio", &(a->ns1__Step::dataOraInizio), "xsd:dateTime"))
				{	soap_flag_dataOraInizio1--;
					continue;
				}
			if (soap_flag_descrizione1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:descrizione", &(a->ns1__Step::descrizione), "xsd:string"))
				{	soap_flag_descrizione1--;
					continue;
				}
			if (soap_flag_esecutore1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:esecutore", &(a->ns1__Step::esecutore), "xsd:string"))
				{	soap_flag_esecutore1--;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:id", &(a->ns1__Step::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Step *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Step, 0, sizeof(ns1__Step), 0, soap_copy_ns1__Step);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Step::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Step);
	if (this->soap_out(soap, tag?tag:"ns1:Step", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Step::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Step(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Step * SOAP_FMAC4 soap_get_ns1__Step(struct soap *soap, ns1__Step *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Step(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Step * SOAP_FMAC2 soap_instantiate_ns1__Step(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Step(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Step, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:StepCompetenza"))
	{	cp->type = SOAP_TYPE_ns1__StepCompetenza;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__StepCompetenza);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__StepCompetenza);
			((ns1__StepCompetenza*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__StepCompetenza[n]);
			if (size)
				*size = n * sizeof(ns1__StepCompetenza);
			for (int i = 0; i < n; i++)
				((ns1__StepCompetenza*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__StepCompetenza*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Step);
		if (size)
			*size = sizeof(ns1__Step);
		((ns1__Step*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Step[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Step);
		for (int i = 0; i < n; i++)
			((ns1__Step*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Step*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Step(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Step %p -> %p\n", q, p));
	*(ns1__Step*)p = *(ns1__Step*)q;
}

void ns1__Stato::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Stato::note);
	soap_default_int(soap, &this->ns1__Stato::tipo);
	/* transient soap skipped */
}

void ns1__Stato::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Stato::note);
	/* transient soap skipped */
}

int ns1__Stato::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Stato(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Stato(struct soap *soap, const char *tag, int id, const ns1__Stato *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Stato), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:note", -1, &(a->ns1__Stato::note), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:tipo", -1, &(a->ns1__Stato::tipo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Stato::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Stato(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Stato * SOAP_FMAC4 soap_in_ns1__Stato(struct soap *soap, const char *tag, ns1__Stato *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Stato *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Stato, sizeof(ns1__Stato), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Stato)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Stato *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_note1 = 1;
	size_t soap_flag_tipo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:note", &(a->ns1__Stato::note), "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			if (soap_flag_tipo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:tipo", &(a->ns1__Stato::tipo), "xsd:int"))
				{	soap_flag_tipo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Stato *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Stato, 0, sizeof(ns1__Stato), 0, soap_copy_ns1__Stato);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tipo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Stato::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Stato);
	if (this->soap_out(soap, tag?tag:"ns1:Stato", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Stato::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Stato(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Stato * SOAP_FMAC4 soap_get_ns1__Stato(struct soap *soap, ns1__Stato *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Stato(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Stato * SOAP_FMAC2 soap_instantiate_ns1__Stato(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Stato(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Stato, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Stato);
		if (size)
			*size = sizeof(ns1__Stato);
		((ns1__Stato*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Stato[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Stato);
		for (int i = 0; i < n; i++)
			((ns1__Stato*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Stato*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Stato(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Stato %p -> %p\n", q, p));
	*(ns1__Stato*)p = *(ns1__Stato*)q;
}

void ns1__ArrayOfNota::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfNota::__sizeitem = 0;
	this->ns1__ArrayOfNota::item = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfNota::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfNota::item)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfNota::__sizeitem; i++)
		{
			soap_serialize_PointerTons1__Nota(soap, this->ns1__ArrayOfNota::item + i);
		}
	}
	/* transient soap skipped */
}

int ns1__ArrayOfNota::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfNota(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfNota(struct soap *soap, const char *tag, int id, const ns1__ArrayOfNota *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfNota), type))
		return soap->error;
	if (a->ns1__ArrayOfNota::item)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfNota::__sizeitem; i++)
			if (soap_out_PointerTons1__Nota(soap, "ns1:item", -1, a->ns1__ArrayOfNota::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfNota::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfNota(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfNota * SOAP_FMAC4 soap_in_ns1__ArrayOfNota(struct soap *soap, const char *tag, ns1__ArrayOfNota *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfNota *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfNota, sizeof(ns1__ArrayOfNota), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfNota)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfNota *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:item", 1, NULL))
			{	if (a->ns1__ArrayOfNota::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->ns1__ArrayOfNota::item = (ns1__Nota **)soap_push_block(soap, soap_blist_item1, sizeof(ns1__Nota *));
					if (a->ns1__ArrayOfNota::item == NULL)
						return NULL;
					*a->ns1__ArrayOfNota::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Nota(soap, "ns1:item", a->ns1__ArrayOfNota::item, "ns1:Nota"))
				{	a->ns1__ArrayOfNota::__sizeitem++;
					a->ns1__ArrayOfNota::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfNota::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->ns1__ArrayOfNota::__sizeitem)
			a->ns1__ArrayOfNota::item = (ns1__Nota **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->ns1__ArrayOfNota::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfNota *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfNota, 0, sizeof(ns1__ArrayOfNota), 0, soap_copy_ns1__ArrayOfNota);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfNota::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfNota);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfNota", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfNota::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfNota(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfNota * SOAP_FMAC4 soap_get_ns1__ArrayOfNota(struct soap *soap, ns1__ArrayOfNota *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfNota(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfNota * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfNota(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfNota(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfNota, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfNota);
		if (size)
			*size = sizeof(ns1__ArrayOfNota);
		((ns1__ArrayOfNota*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfNota[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfNota);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfNota*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfNota*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfNota(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfNota %p -> %p\n", q, p));
	*(ns1__ArrayOfNota*)p = *(ns1__ArrayOfNota*)q;
}

void ns1__Nota::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Nota::attivita);
	this->ns1__Nota::dataOra = NULL;
	soap_default_string(soap, &this->ns1__Nota::descrizioneUtente);
	soap_default_string(soap, &this->ns1__Nota::testo);
	/* transient soap skipped */
}

void ns1__Nota::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__Nota::attivita);
	soap_serialize_PointerTotime(soap, &this->ns1__Nota::dataOra);
	soap_serialize_string(soap, &this->ns1__Nota::descrizioneUtente);
	soap_serialize_string(soap, &this->ns1__Nota::testo);
	/* transient soap skipped */
}

int ns1__Nota::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Nota(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Nota(struct soap *soap, const char *tag, int id, const ns1__Nota *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Nota), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:attivita", -1, &(a->ns1__Nota::attivita), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:dataOra", -1, &(a->ns1__Nota::dataOra), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:descrizioneUtente", -1, &(a->ns1__Nota::descrizioneUtente), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:testo", -1, &(a->ns1__Nota::testo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Nota::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Nota(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Nota * SOAP_FMAC4 soap_in_ns1__Nota(struct soap *soap, const char *tag, ns1__Nota *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Nota *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Nota, sizeof(ns1__Nota), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Nota)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Nota *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_attivita1 = 1;
	size_t soap_flag_dataOra1 = 1;
	size_t soap_flag_descrizioneUtente1 = 1;
	size_t soap_flag_testo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attivita1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:attivita", &(a->ns1__Nota::attivita), "xsd:string"))
				{	soap_flag_attivita1--;
					continue;
				}
			if (soap_flag_dataOra1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:dataOra", &(a->ns1__Nota::dataOra), "xsd:dateTime"))
				{	soap_flag_dataOra1--;
					continue;
				}
			if (soap_flag_descrizioneUtente1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:descrizioneUtente", &(a->ns1__Nota::descrizioneUtente), "xsd:string"))
				{	soap_flag_descrizioneUtente1--;
					continue;
				}
			if (soap_flag_testo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:testo", &(a->ns1__Nota::testo), "xsd:string"))
				{	soap_flag_testo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Nota *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Nota, 0, sizeof(ns1__Nota), 0, soap_copy_ns1__Nota);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Nota::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Nota);
	if (this->soap_out(soap, tag?tag:"ns1:Nota", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Nota::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Nota(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Nota * SOAP_FMAC4 soap_get_ns1__Nota(struct soap *soap, ns1__Nota *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Nota(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Nota * SOAP_FMAC2 soap_instantiate_ns1__Nota(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Nota(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Nota, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Nota);
		if (size)
			*size = sizeof(ns1__Nota);
		((ns1__Nota*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Nota[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Nota);
		for (int i = 0; i < n; i++)
			((ns1__Nota*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Nota*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Nota(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Nota %p -> %p\n", q, p));
	*(ns1__Nota*)p = *(ns1__Nota*)q;
}

void ns1__MetaDato::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__MetaDato::nome);
	soap_default_int(soap, &this->ns1__MetaDato::tipo);
	soap_default_string(soap, &this->ns1__MetaDato::valore);
	/* transient soap skipped */
}

void ns1__MetaDato::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__MetaDato::nome);
	soap_serialize_string(soap, &this->ns1__MetaDato::valore);
	/* transient soap skipped */
}

int ns1__MetaDato::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MetaDato(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MetaDato(struct soap *soap, const char *tag, int id, const ns1__MetaDato *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MetaDato), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:nome", -1, &(a->ns1__MetaDato::nome), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:tipo", -1, &(a->ns1__MetaDato::tipo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:valore", -1, &(a->ns1__MetaDato::valore), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__MetaDato::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MetaDato(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MetaDato * SOAP_FMAC4 soap_in_ns1__MetaDato(struct soap *soap, const char *tag, ns1__MetaDato *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MetaDato *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MetaDato, sizeof(ns1__MetaDato), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MetaDato)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MetaDato *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nome1 = 1;
	size_t soap_flag_tipo1 = 1;
	size_t soap_flag_valore1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nome1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nome", &(a->ns1__MetaDato::nome), "xsd:string"))
				{	soap_flag_nome1--;
					continue;
				}
			if (soap_flag_tipo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:tipo", &(a->ns1__MetaDato::tipo), "xsd:int"))
				{	soap_flag_tipo1--;
					continue;
				}
			if (soap_flag_valore1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:valore", &(a->ns1__MetaDato::valore), "xsd:string"))
				{	soap_flag_valore1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MetaDato *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MetaDato, 0, sizeof(ns1__MetaDato), 0, soap_copy_ns1__MetaDato);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tipo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__MetaDato::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MetaDato);
	if (this->soap_out(soap, tag?tag:"ns1:MetaDato", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MetaDato::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MetaDato(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MetaDato * SOAP_FMAC4 soap_get_ns1__MetaDato(struct soap *soap, ns1__MetaDato *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MetaDato(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__MetaDato * SOAP_FMAC2 soap_instantiate_ns1__MetaDato(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MetaDato(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MetaDato, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__MetaDato);
		if (size)
			*size = sizeof(ns1__MetaDato);
		((ns1__MetaDato*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__MetaDato[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MetaDato);
		for (int i = 0; i < n; i++)
			((ns1__MetaDato*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MetaDato*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MetaDato(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MetaDato %p -> %p\n", q, p));
	*(ns1__MetaDato*)p = *(ns1__MetaDato*)q;
}

void ns1__EccezioneSistema::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__EccezioneSistema::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__EccezioneSistema::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EccezioneSistema(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EccezioneSistema(struct soap *soap, const char *tag, int id, const ns1__EccezioneSistema *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EccezioneSistema), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__EccezioneSistema::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EccezioneSistema(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EccezioneSistema * SOAP_FMAC4 soap_in_ns1__EccezioneSistema(struct soap *soap, const char *tag, ns1__EccezioneSistema *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EccezioneSistema *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EccezioneSistema, sizeof(ns1__EccezioneSistema), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EccezioneSistema)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EccezioneSistema *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EccezioneSistema *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EccezioneSistema, 0, sizeof(ns1__EccezioneSistema), 0, soap_copy_ns1__EccezioneSistema);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__EccezioneSistema::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EccezioneSistema);
	if (this->soap_out(soap, tag?tag:"ns1:EccezioneSistema", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EccezioneSistema::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EccezioneSistema(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EccezioneSistema * SOAP_FMAC4 soap_get_ns1__EccezioneSistema(struct soap *soap, ns1__EccezioneSistema *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EccezioneSistema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__EccezioneSistema * SOAP_FMAC2 soap_instantiate_ns1__EccezioneSistema(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EccezioneSistema(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EccezioneSistema, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__EccezioneSistema);
		if (size)
			*size = sizeof(ns1__EccezioneSistema);
		((ns1__EccezioneSistema*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__EccezioneSistema[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EccezioneSistema);
		for (int i = 0; i < n; i++)
			((ns1__EccezioneSistema*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EccezioneSistema*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EccezioneSistema(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EccezioneSistema %p -> %p\n", q, p));
	*(ns1__EccezioneSistema*)p = *(ns1__EccezioneSistema*)q;
}

void ns1__EccezioneAutenticazione::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__EccezioneAutenticazione::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__EccezioneAutenticazione::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EccezioneAutenticazione(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EccezioneAutenticazione(struct soap *soap, const char *tag, int id, const ns1__EccezioneAutenticazione *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EccezioneAutenticazione), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__EccezioneAutenticazione::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EccezioneAutenticazione(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EccezioneAutenticazione * SOAP_FMAC4 soap_in_ns1__EccezioneAutenticazione(struct soap *soap, const char *tag, ns1__EccezioneAutenticazione *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EccezioneAutenticazione *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EccezioneAutenticazione, sizeof(ns1__EccezioneAutenticazione), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EccezioneAutenticazione)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EccezioneAutenticazione *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EccezioneAutenticazione *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EccezioneAutenticazione, 0, sizeof(ns1__EccezioneAutenticazione), 0, soap_copy_ns1__EccezioneAutenticazione);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__EccezioneAutenticazione::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EccezioneAutenticazione);
	if (this->soap_out(soap, tag?tag:"ns1:EccezioneAutenticazione", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__EccezioneAutenticazione::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EccezioneAutenticazione(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EccezioneAutenticazione * SOAP_FMAC4 soap_get_ns1__EccezioneAutenticazione(struct soap *soap, ns1__EccezioneAutenticazione *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EccezioneAutenticazione(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__EccezioneAutenticazione * SOAP_FMAC2 soap_instantiate_ns1__EccezioneAutenticazione(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EccezioneAutenticazione(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EccezioneAutenticazione, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__EccezioneAutenticazione);
		if (size)
			*size = sizeof(ns1__EccezioneAutenticazione);
		((ns1__EccezioneAutenticazione*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__EccezioneAutenticazione[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EccezioneAutenticazione);
		for (int i = 0; i < n; i++)
			((ns1__EccezioneAutenticazione*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EccezioneAutenticazione*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EccezioneAutenticazione(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EccezioneAutenticazione %p -> %p\n", q, p));
	*(ns1__EccezioneAutenticazione*)p = *(ns1__EccezioneAutenticazione*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getGiustificativi(struct soap *soap, struct __ns1__getGiustificativi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getGiustificativi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getGiustificativi(struct soap *soap, const struct __ns1__getGiustificativi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getGiustificativi(soap, &a->ns1__getGiustificativi);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getGiustificativi(struct soap *soap, const char *tag, int id, const struct __ns1__getGiustificativi *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getGiustificativi(soap, "ns1:getGiustificativi", -1, &a->ns1__getGiustificativi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGiustificativi * SOAP_FMAC4 soap_in___ns1__getGiustificativi(struct soap *soap, const char *tag, struct __ns1__getGiustificativi *a, const char *type)
{
	size_t soap_flag_ns1__getGiustificativi = 1;
	short soap_flag;
	a = (struct __ns1__getGiustificativi *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getGiustificativi, sizeof(struct __ns1__getGiustificativi), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getGiustificativi(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getGiustificativi && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getGiustificativi(soap, "ns1:getGiustificativi", &a->ns1__getGiustificativi, ""))
				{	soap_flag_ns1__getGiustificativi--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getGiustificativi(struct soap *soap, const struct __ns1__getGiustificativi *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getGiustificativi(soap, tag?tag:"-ns1:getGiustificativi", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGiustificativi * SOAP_FMAC4 soap_get___ns1__getGiustificativi(struct soap *soap, struct __ns1__getGiustificativi *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getGiustificativi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getGiustificativi * SOAP_FMAC2 soap_instantiate___ns1__getGiustificativi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getGiustificativi(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getGiustificativi, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getGiustificativi);
		if (size)
			*size = sizeof(struct __ns1__getGiustificativi);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getGiustificativi[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getGiustificativi);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getGiustificativi*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getGiustificativi(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getGiustificativi %p -> %p\n", q, p));
	*(struct __ns1__getGiustificativi*)p = *(struct __ns1__getGiustificativi*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getFlussi(struct soap *soap, struct __ns1__getFlussi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getFlussi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getFlussi(struct soap *soap, const struct __ns1__getFlussi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getFlussi(soap, &a->ns1__getFlussi);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getFlussi(struct soap *soap, const char *tag, int id, const struct __ns1__getFlussi *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getFlussi(soap, "ns1:getFlussi", -1, &a->ns1__getFlussi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFlussi * SOAP_FMAC4 soap_in___ns1__getFlussi(struct soap *soap, const char *tag, struct __ns1__getFlussi *a, const char *type)
{
	size_t soap_flag_ns1__getFlussi = 1;
	short soap_flag;
	a = (struct __ns1__getFlussi *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getFlussi, sizeof(struct __ns1__getFlussi), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getFlussi(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getFlussi && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getFlussi(soap, "ns1:getFlussi", &a->ns1__getFlussi, ""))
				{	soap_flag_ns1__getFlussi--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getFlussi(struct soap *soap, const struct __ns1__getFlussi *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getFlussi(soap, tag?tag:"-ns1:getFlussi", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFlussi * SOAP_FMAC4 soap_get___ns1__getFlussi(struct soap *soap, struct __ns1__getFlussi *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getFlussi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getFlussi * SOAP_FMAC2 soap_instantiate___ns1__getFlussi(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getFlussi(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getFlussi, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getFlussi);
		if (size)
			*size = sizeof(struct __ns1__getFlussi);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getFlussi[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getFlussi);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getFlussi*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getFlussi(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getFlussi %p -> %p\n", q, p));
	*(struct __ns1__getFlussi*)p = *(struct __ns1__getFlussi*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__avanzaProcedimento(struct soap *soap, struct __ns1__avanzaProcedimento *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__avanzaProcedimento = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__avanzaProcedimento(struct soap *soap, const struct __ns1__avanzaProcedimento *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__avanzaProcedimento(soap, &a->ns1__avanzaProcedimento);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__avanzaProcedimento(struct soap *soap, const char *tag, int id, const struct __ns1__avanzaProcedimento *a, const char *type)
{
	if (soap_out_PointerTo_ns1__avanzaProcedimento(soap, "ns1:avanzaProcedimento", -1, &a->ns1__avanzaProcedimento, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__avanzaProcedimento * SOAP_FMAC4 soap_in___ns1__avanzaProcedimento(struct soap *soap, const char *tag, struct __ns1__avanzaProcedimento *a, const char *type)
{
	size_t soap_flag_ns1__avanzaProcedimento = 1;
	short soap_flag;
	a = (struct __ns1__avanzaProcedimento *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__avanzaProcedimento, sizeof(struct __ns1__avanzaProcedimento), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__avanzaProcedimento(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__avanzaProcedimento && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__avanzaProcedimento(soap, "ns1:avanzaProcedimento", &a->ns1__avanzaProcedimento, ""))
				{	soap_flag_ns1__avanzaProcedimento--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__avanzaProcedimento(struct soap *soap, const struct __ns1__avanzaProcedimento *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__avanzaProcedimento(soap, tag?tag:"-ns1:avanzaProcedimento", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__avanzaProcedimento * SOAP_FMAC4 soap_get___ns1__avanzaProcedimento(struct soap *soap, struct __ns1__avanzaProcedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__avanzaProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__avanzaProcedimento * SOAP_FMAC2 soap_instantiate___ns1__avanzaProcedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__avanzaProcedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__avanzaProcedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__avanzaProcedimento);
		if (size)
			*size = sizeof(struct __ns1__avanzaProcedimento);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__avanzaProcedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__avanzaProcedimento);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__avanzaProcedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__avanzaProcedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__avanzaProcedimento %p -> %p\n", q, p));
	*(struct __ns1__avanzaProcedimento*)p = *(struct __ns1__avanzaProcedimento*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcedimento(struct soap *soap, struct __ns1__getProcedimento *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcedimento = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcedimento(struct soap *soap, const struct __ns1__getProcedimento *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getProcedimento(soap, &a->ns1__getProcedimento);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcedimento(struct soap *soap, const char *tag, int id, const struct __ns1__getProcedimento *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getProcedimento(soap, "ns1:getProcedimento", -1, &a->ns1__getProcedimento, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcedimento * SOAP_FMAC4 soap_in___ns1__getProcedimento(struct soap *soap, const char *tag, struct __ns1__getProcedimento *a, const char *type)
{
	size_t soap_flag_ns1__getProcedimento = 1;
	short soap_flag;
	a = (struct __ns1__getProcedimento *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcedimento, sizeof(struct __ns1__getProcedimento), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcedimento(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcedimento && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getProcedimento(soap, "ns1:getProcedimento", &a->ns1__getProcedimento, ""))
				{	soap_flag_ns1__getProcedimento--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcedimento(struct soap *soap, const struct __ns1__getProcedimento *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcedimento(soap, tag?tag:"-ns1:getProcedimento", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcedimento * SOAP_FMAC4 soap_get___ns1__getProcedimento(struct soap *soap, struct __ns1__getProcedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcedimento * SOAP_FMAC2 soap_instantiate___ns1__getProcedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcedimento);
		if (size)
			*size = sizeof(struct __ns1__getProcedimento);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getProcedimento);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getProcedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcedimento %p -> %p\n", q, p));
	*(struct __ns1__getProcedimento*)p = *(struct __ns1__getProcedimento*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, struct __ns1__aggiungiDocumentoAlProcedimento *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__aggiungiDocumentoAlProcedimento = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, const struct __ns1__aggiungiDocumentoAlProcedimento *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__aggiungiDocumentoAlProcedimento(soap, &a->ns1__aggiungiDocumentoAlProcedimento);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, const char *tag, int id, const struct __ns1__aggiungiDocumentoAlProcedimento *a, const char *type)
{
	if (soap_out_PointerTo_ns1__aggiungiDocumentoAlProcedimento(soap, "ns1:aggiungiDocumentoAlProcedimento", -1, &a->ns1__aggiungiDocumentoAlProcedimento, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__aggiungiDocumentoAlProcedimento * SOAP_FMAC4 soap_in___ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, const char *tag, struct __ns1__aggiungiDocumentoAlProcedimento *a, const char *type)
{
	size_t soap_flag_ns1__aggiungiDocumentoAlProcedimento = 1;
	short soap_flag;
	a = (struct __ns1__aggiungiDocumentoAlProcedimento *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__aggiungiDocumentoAlProcedimento, sizeof(struct __ns1__aggiungiDocumentoAlProcedimento), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__aggiungiDocumentoAlProcedimento(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__aggiungiDocumentoAlProcedimento && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__aggiungiDocumentoAlProcedimento(soap, "ns1:aggiungiDocumentoAlProcedimento", &a->ns1__aggiungiDocumentoAlProcedimento, ""))
				{	soap_flag_ns1__aggiungiDocumentoAlProcedimento--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, const struct __ns1__aggiungiDocumentoAlProcedimento *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__aggiungiDocumentoAlProcedimento(soap, tag?tag:"-ns1:aggiungiDocumentoAlProcedimento", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__aggiungiDocumentoAlProcedimento * SOAP_FMAC4 soap_get___ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, struct __ns1__aggiungiDocumentoAlProcedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__aggiungiDocumentoAlProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__aggiungiDocumentoAlProcedimento * SOAP_FMAC2 soap_instantiate___ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__aggiungiDocumentoAlProcedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__aggiungiDocumentoAlProcedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__aggiungiDocumentoAlProcedimento);
		if (size)
			*size = sizeof(struct __ns1__aggiungiDocumentoAlProcedimento);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__aggiungiDocumentoAlProcedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__aggiungiDocumentoAlProcedimento);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__aggiungiDocumentoAlProcedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__aggiungiDocumentoAlProcedimento %p -> %p\n", q, p));
	*(struct __ns1__aggiungiDocumentoAlProcedimento*)p = *(struct __ns1__aggiungiDocumentoAlProcedimento*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__attivaProcedimentoWide(struct soap *soap, struct __ns1__attivaProcedimentoWide *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__attivaProcedimentoWide = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__attivaProcedimentoWide(struct soap *soap, const struct __ns1__attivaProcedimentoWide *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__attivaProcedimentoWide(soap, &a->ns1__attivaProcedimentoWide);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__attivaProcedimentoWide(struct soap *soap, const char *tag, int id, const struct __ns1__attivaProcedimentoWide *a, const char *type)
{
	if (soap_out_PointerTo_ns1__attivaProcedimentoWide(soap, "ns1:attivaProcedimentoWide", -1, &a->ns1__attivaProcedimentoWide, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__attivaProcedimentoWide * SOAP_FMAC4 soap_in___ns1__attivaProcedimentoWide(struct soap *soap, const char *tag, struct __ns1__attivaProcedimentoWide *a, const char *type)
{
	size_t soap_flag_ns1__attivaProcedimentoWide = 1;
	short soap_flag;
	a = (struct __ns1__attivaProcedimentoWide *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__attivaProcedimentoWide, sizeof(struct __ns1__attivaProcedimentoWide), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__attivaProcedimentoWide(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__attivaProcedimentoWide && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__attivaProcedimentoWide(soap, "ns1:attivaProcedimentoWide", &a->ns1__attivaProcedimentoWide, ""))
				{	soap_flag_ns1__attivaProcedimentoWide--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__attivaProcedimentoWide(struct soap *soap, const struct __ns1__attivaProcedimentoWide *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__attivaProcedimentoWide(soap, tag?tag:"-ns1:attivaProcedimentoWide", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__attivaProcedimentoWide * SOAP_FMAC4 soap_get___ns1__attivaProcedimentoWide(struct soap *soap, struct __ns1__attivaProcedimentoWide *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__attivaProcedimentoWide(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__attivaProcedimentoWide * SOAP_FMAC2 soap_instantiate___ns1__attivaProcedimentoWide(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__attivaProcedimentoWide(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__attivaProcedimentoWide, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__attivaProcedimentoWide);
		if (size)
			*size = sizeof(struct __ns1__attivaProcedimentoWide);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__attivaProcedimentoWide[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__attivaProcedimentoWide);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__attivaProcedimentoWide*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__attivaProcedimentoWide(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__attivaProcedimentoWide %p -> %p\n", q, p));
	*(struct __ns1__attivaProcedimentoWide*)p = *(struct __ns1__attivaProcedimentoWide*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__attivaProcedimento(struct soap *soap, struct __ns1__attivaProcedimento *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__attivaProcedimento = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__attivaProcedimento(struct soap *soap, const struct __ns1__attivaProcedimento *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__attivaProcedimento(soap, &a->ns1__attivaProcedimento);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__attivaProcedimento(struct soap *soap, const char *tag, int id, const struct __ns1__attivaProcedimento *a, const char *type)
{
	if (soap_out_PointerTo_ns1__attivaProcedimento(soap, "ns1:attivaProcedimento", -1, &a->ns1__attivaProcedimento, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__attivaProcedimento * SOAP_FMAC4 soap_in___ns1__attivaProcedimento(struct soap *soap, const char *tag, struct __ns1__attivaProcedimento *a, const char *type)
{
	size_t soap_flag_ns1__attivaProcedimento = 1;
	short soap_flag;
	a = (struct __ns1__attivaProcedimento *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__attivaProcedimento, sizeof(struct __ns1__attivaProcedimento), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__attivaProcedimento(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__attivaProcedimento && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__attivaProcedimento(soap, "ns1:attivaProcedimento", &a->ns1__attivaProcedimento, ""))
				{	soap_flag_ns1__attivaProcedimento--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__attivaProcedimento(struct soap *soap, const struct __ns1__attivaProcedimento *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__attivaProcedimento(soap, tag?tag:"-ns1:attivaProcedimento", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__attivaProcedimento * SOAP_FMAC4 soap_get___ns1__attivaProcedimento(struct soap *soap, struct __ns1__attivaProcedimento *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__attivaProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__attivaProcedimento * SOAP_FMAC2 soap_instantiate___ns1__attivaProcedimento(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__attivaProcedimento(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__attivaProcedimento, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__attivaProcedimento);
		if (size)
			*size = sizeof(struct __ns1__attivaProcedimento);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__attivaProcedimento[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__attivaProcedimento);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__attivaProcedimento*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__attivaProcedimento(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__attivaProcedimento %p -> %p\n", q, p));
	*(struct __ns1__attivaProcedimento*)p = *(struct __ns1__attivaProcedimento*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__login(struct soap *soap, struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__login(struct soap *soap, const struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__login(soap, &a->ns1__login);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__login(struct soap *soap, const char *tag, int id, const struct __ns1__login *a, const char *type)
{
	if (soap_out_PointerTo_ns1__login(soap, "ns1:login", -1, &a->ns1__login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_in___ns1__login(struct soap *soap, const char *tag, struct __ns1__login *a, const char *type)
{
	size_t soap_flag_ns1__login = 1;
	short soap_flag;
	a = (struct __ns1__login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__login, sizeof(struct __ns1__login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__login(soap, "ns1:login", &a->ns1__login, ""))
				{	soap_flag_ns1__login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__login(struct soap *soap, const struct __ns1__login *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__login(soap, tag?tag:"-ns1:login", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_get___ns1__login(struct soap *soap, struct __ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__login * SOAP_FMAC2 soap_instantiate___ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__login);
		if (size)
			*size = sizeof(struct __ns1__login);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__login[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__login);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__login %p -> %p\n", q, p));
	*(struct __ns1__login*)p = *(struct __ns1__login*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getToken(struct soap *soap, struct __ns1__getToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getToken(struct soap *soap, const struct __ns1__getToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getToken(soap, &a->ns1__getToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getToken(struct soap *soap, const char *tag, int id, const struct __ns1__getToken *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getToken(soap, "ns1:getToken", -1, &a->ns1__getToken, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getToken * SOAP_FMAC4 soap_in___ns1__getToken(struct soap *soap, const char *tag, struct __ns1__getToken *a, const char *type)
{
	size_t soap_flag_ns1__getToken = 1;
	short soap_flag;
	a = (struct __ns1__getToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getToken, sizeof(struct __ns1__getToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getToken(soap, "ns1:getToken", &a->ns1__getToken, ""))
				{	soap_flag_ns1__getToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getToken(struct soap *soap, const struct __ns1__getToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getToken(soap, tag?tag:"-ns1:getToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getToken * SOAP_FMAC4 soap_get___ns1__getToken(struct soap *soap, struct __ns1__getToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getToken * SOAP_FMAC2 soap_instantiate___ns1__getToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getToken);
		if (size)
			*size = sizeof(struct __ns1__getToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getToken);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getToken %p -> %p\n", q, p));
	*(struct __ns1__getToken*)p = *(struct __ns1__getToken*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->ns1__fault = NULL;
	a->ns1__fault1 = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__EccezioneAutenticazione(soap, &a->ns1__fault);
	soap_serialize_PointerTons1__EccezioneSistema(soap, &a->ns1__fault1);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_out_PointerTons1__EccezioneAutenticazione(soap, "ns1:fault", -1, &a->ns1__fault, ""))
		return soap->error;
	if (soap_out_PointerTons1__EccezioneSistema(soap, "ns1:fault1", -1, &a->ns1__fault1, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns1__fault = 1;
	size_t soap_flag_ns1__fault1 = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EccezioneAutenticazione(soap, "ns1:fault", &a->ns1__fault, "ns1:EccezioneAutenticazione"))
				{	soap_flag_ns1__fault--;
					continue;
				}
			if (soap_flag_ns1__fault1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EccezioneSistema(soap, "ns1:fault1", &a->ns1__fault1, "ns1:EccezioneSistema"))
				{	soap_flag_ns1__fault1--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getGiustificativiResponse(struct soap *soap, _ns1__getGiustificativiResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getGiustificativiResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getGiustificativiResponse(struct soap *soap, const char *tag, int id, _ns1__getGiustificativiResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getGiustificativiResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getGiustificativiResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getGiustificativiResponse(struct soap *soap, const char *tag, _ns1__getGiustificativiResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getGiustificativiResponse **)soap_malloc(soap, sizeof(_ns1__getGiustificativiResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getGiustificativiResponse *)soap_instantiate__ns1__getGiustificativiResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getGiustificativiResponse ** p = (_ns1__getGiustificativiResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getGiustificativiResponse, sizeof(_ns1__getGiustificativiResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getGiustificativiResponse(struct soap *soap, _ns1__getGiustificativiResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getGiustificativiResponse);
	if (soap_out_PointerTo_ns1__getGiustificativiResponse(soap, tag?tag:"ns1:getGiustificativiResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getGiustificativiResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getGiustificativiResponse(struct soap *soap, _ns1__getGiustificativiResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getGiustificativiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getGiustificativi(struct soap *soap, _ns1__getGiustificativi *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getGiustificativi))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getGiustificativi(struct soap *soap, const char *tag, int id, _ns1__getGiustificativi *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getGiustificativi);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getGiustificativi ** SOAP_FMAC4 soap_in_PointerTo_ns1__getGiustificativi(struct soap *soap, const char *tag, _ns1__getGiustificativi **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getGiustificativi **)soap_malloc(soap, sizeof(_ns1__getGiustificativi *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getGiustificativi *)soap_instantiate__ns1__getGiustificativi(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getGiustificativi ** p = (_ns1__getGiustificativi **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getGiustificativi, sizeof(_ns1__getGiustificativi), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getGiustificativi(struct soap *soap, _ns1__getGiustificativi *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getGiustificativi);
	if (soap_out_PointerTo_ns1__getGiustificativi(soap, tag?tag:"ns1:getGiustificativi", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getGiustificativi ** SOAP_FMAC4 soap_get_PointerTo_ns1__getGiustificativi(struct soap *soap, _ns1__getGiustificativi **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getGiustificativi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getFlussiResponse(struct soap *soap, _ns1__getFlussiResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getFlussiResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getFlussiResponse(struct soap *soap, const char *tag, int id, _ns1__getFlussiResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getFlussiResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getFlussiResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getFlussiResponse(struct soap *soap, const char *tag, _ns1__getFlussiResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getFlussiResponse **)soap_malloc(soap, sizeof(_ns1__getFlussiResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getFlussiResponse *)soap_instantiate__ns1__getFlussiResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getFlussiResponse ** p = (_ns1__getFlussiResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getFlussiResponse, sizeof(_ns1__getFlussiResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getFlussiResponse(struct soap *soap, _ns1__getFlussiResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getFlussiResponse);
	if (soap_out_PointerTo_ns1__getFlussiResponse(soap, tag?tag:"ns1:getFlussiResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getFlussiResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getFlussiResponse(struct soap *soap, _ns1__getFlussiResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getFlussiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getFlussi(struct soap *soap, _ns1__getFlussi *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getFlussi))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getFlussi(struct soap *soap, const char *tag, int id, _ns1__getFlussi *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getFlussi);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getFlussi ** SOAP_FMAC4 soap_in_PointerTo_ns1__getFlussi(struct soap *soap, const char *tag, _ns1__getFlussi **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getFlussi **)soap_malloc(soap, sizeof(_ns1__getFlussi *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getFlussi *)soap_instantiate__ns1__getFlussi(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getFlussi ** p = (_ns1__getFlussi **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getFlussi, sizeof(_ns1__getFlussi), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getFlussi(struct soap *soap, _ns1__getFlussi *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getFlussi);
	if (soap_out_PointerTo_ns1__getFlussi(soap, tag?tag:"ns1:getFlussi", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getFlussi ** SOAP_FMAC4 soap_get_PointerTo_ns1__getFlussi(struct soap *soap, _ns1__getFlussi **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getFlussi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__avanzaProcedimentoResponse(struct soap *soap, _ns1__avanzaProcedimentoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__avanzaProcedimentoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__avanzaProcedimentoResponse(struct soap *soap, const char *tag, int id, _ns1__avanzaProcedimentoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__avanzaProcedimentoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__avanzaProcedimentoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__avanzaProcedimentoResponse(struct soap *soap, const char *tag, _ns1__avanzaProcedimentoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__avanzaProcedimentoResponse **)soap_malloc(soap, sizeof(_ns1__avanzaProcedimentoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__avanzaProcedimentoResponse *)soap_instantiate__ns1__avanzaProcedimentoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__avanzaProcedimentoResponse ** p = (_ns1__avanzaProcedimentoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__avanzaProcedimentoResponse, sizeof(_ns1__avanzaProcedimentoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__avanzaProcedimentoResponse(struct soap *soap, _ns1__avanzaProcedimentoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__avanzaProcedimentoResponse);
	if (soap_out_PointerTo_ns1__avanzaProcedimentoResponse(soap, tag?tag:"ns1:avanzaProcedimentoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__avanzaProcedimentoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__avanzaProcedimentoResponse(struct soap *soap, _ns1__avanzaProcedimentoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__avanzaProcedimentoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__avanzaProcedimento(struct soap *soap, _ns1__avanzaProcedimento *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__avanzaProcedimento))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__avanzaProcedimento(struct soap *soap, const char *tag, int id, _ns1__avanzaProcedimento *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__avanzaProcedimento);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__avanzaProcedimento ** SOAP_FMAC4 soap_in_PointerTo_ns1__avanzaProcedimento(struct soap *soap, const char *tag, _ns1__avanzaProcedimento **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__avanzaProcedimento **)soap_malloc(soap, sizeof(_ns1__avanzaProcedimento *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__avanzaProcedimento *)soap_instantiate__ns1__avanzaProcedimento(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__avanzaProcedimento ** p = (_ns1__avanzaProcedimento **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__avanzaProcedimento, sizeof(_ns1__avanzaProcedimento), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__avanzaProcedimento(struct soap *soap, _ns1__avanzaProcedimento *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__avanzaProcedimento);
	if (soap_out_PointerTo_ns1__avanzaProcedimento(soap, tag?tag:"ns1:avanzaProcedimento", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__avanzaProcedimento ** SOAP_FMAC4 soap_get_PointerTo_ns1__avanzaProcedimento(struct soap *soap, _ns1__avanzaProcedimento **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__avanzaProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getProcedimentoResponse(struct soap *soap, _ns1__getProcedimentoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getProcedimentoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getProcedimentoResponse(struct soap *soap, const char *tag, int id, _ns1__getProcedimentoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getProcedimentoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getProcedimentoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getProcedimentoResponse(struct soap *soap, const char *tag, _ns1__getProcedimentoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getProcedimentoResponse **)soap_malloc(soap, sizeof(_ns1__getProcedimentoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getProcedimentoResponse *)soap_instantiate__ns1__getProcedimentoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getProcedimentoResponse ** p = (_ns1__getProcedimentoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getProcedimentoResponse, sizeof(_ns1__getProcedimentoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getProcedimentoResponse(struct soap *soap, _ns1__getProcedimentoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getProcedimentoResponse);
	if (soap_out_PointerTo_ns1__getProcedimentoResponse(soap, tag?tag:"ns1:getProcedimentoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getProcedimentoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getProcedimentoResponse(struct soap *soap, _ns1__getProcedimentoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getProcedimentoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getProcedimento(struct soap *soap, _ns1__getProcedimento *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getProcedimento))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getProcedimento(struct soap *soap, const char *tag, int id, _ns1__getProcedimento *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getProcedimento);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getProcedimento ** SOAP_FMAC4 soap_in_PointerTo_ns1__getProcedimento(struct soap *soap, const char *tag, _ns1__getProcedimento **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getProcedimento **)soap_malloc(soap, sizeof(_ns1__getProcedimento *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getProcedimento *)soap_instantiate__ns1__getProcedimento(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getProcedimento ** p = (_ns1__getProcedimento **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getProcedimento, sizeof(_ns1__getProcedimento), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getProcedimento(struct soap *soap, _ns1__getProcedimento *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getProcedimento);
	if (soap_out_PointerTo_ns1__getProcedimento(soap, tag?tag:"ns1:getProcedimento", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getProcedimento ** SOAP_FMAC4 soap_get_PointerTo_ns1__getProcedimento(struct soap *soap, _ns1__getProcedimento **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, _ns1__aggiungiDocumentoAlProcedimentoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, const char *tag, int id, _ns1__aggiungiDocumentoAlProcedimentoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__aggiungiDocumentoAlProcedimentoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, const char *tag, _ns1__aggiungiDocumentoAlProcedimentoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__aggiungiDocumentoAlProcedimentoResponse **)soap_malloc(soap, sizeof(_ns1__aggiungiDocumentoAlProcedimentoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__aggiungiDocumentoAlProcedimentoResponse *)soap_instantiate__ns1__aggiungiDocumentoAlProcedimentoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__aggiungiDocumentoAlProcedimentoResponse ** p = (_ns1__aggiungiDocumentoAlProcedimentoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimentoResponse, sizeof(_ns1__aggiungiDocumentoAlProcedimentoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, _ns1__aggiungiDocumentoAlProcedimentoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse);
	if (soap_out_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(soap, tag?tag:"ns1:aggiungiDocumentoAlProcedimentoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__aggiungiDocumentoAlProcedimentoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(struct soap *soap, _ns1__aggiungiDocumentoAlProcedimentoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__aggiungiDocumentoAlProcedimentoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, _ns1__aggiungiDocumentoAlProcedimento *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, const char *tag, int id, _ns1__aggiungiDocumentoAlProcedimento *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__aggiungiDocumentoAlProcedimento ** SOAP_FMAC4 soap_in_PointerTo_ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, const char *tag, _ns1__aggiungiDocumentoAlProcedimento **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__aggiungiDocumentoAlProcedimento **)soap_malloc(soap, sizeof(_ns1__aggiungiDocumentoAlProcedimento *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__aggiungiDocumentoAlProcedimento *)soap_instantiate__ns1__aggiungiDocumentoAlProcedimento(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__aggiungiDocumentoAlProcedimento ** p = (_ns1__aggiungiDocumentoAlProcedimento **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__aggiungiDocumentoAlProcedimento, sizeof(_ns1__aggiungiDocumentoAlProcedimento), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, _ns1__aggiungiDocumentoAlProcedimento *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__aggiungiDocumentoAlProcedimento);
	if (soap_out_PointerTo_ns1__aggiungiDocumentoAlProcedimento(soap, tag?tag:"ns1:aggiungiDocumentoAlProcedimento", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__aggiungiDocumentoAlProcedimento ** SOAP_FMAC4 soap_get_PointerTo_ns1__aggiungiDocumentoAlProcedimento(struct soap *soap, _ns1__aggiungiDocumentoAlProcedimento **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__aggiungiDocumentoAlProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__attivaProcedimentoWideResponse(struct soap *soap, _ns1__attivaProcedimentoWideResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__attivaProcedimentoWideResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__attivaProcedimentoWideResponse(struct soap *soap, const char *tag, int id, _ns1__attivaProcedimentoWideResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__attivaProcedimentoWideResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoWideResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__attivaProcedimentoWideResponse(struct soap *soap, const char *tag, _ns1__attivaProcedimentoWideResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__attivaProcedimentoWideResponse **)soap_malloc(soap, sizeof(_ns1__attivaProcedimentoWideResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__attivaProcedimentoWideResponse *)soap_instantiate__ns1__attivaProcedimentoWideResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__attivaProcedimentoWideResponse ** p = (_ns1__attivaProcedimentoWideResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__attivaProcedimentoWideResponse, sizeof(_ns1__attivaProcedimentoWideResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__attivaProcedimentoWideResponse(struct soap *soap, _ns1__attivaProcedimentoWideResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__attivaProcedimentoWideResponse);
	if (soap_out_PointerTo_ns1__attivaProcedimentoWideResponse(soap, tag?tag:"ns1:attivaProcedimentoWideResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__attivaProcedimentoWideResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__attivaProcedimentoWideResponse(struct soap *soap, _ns1__attivaProcedimentoWideResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__attivaProcedimentoWideResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__attivaProcedimentoWide(struct soap *soap, _ns1__attivaProcedimentoWide *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__attivaProcedimentoWide))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__attivaProcedimentoWide(struct soap *soap, const char *tag, int id, _ns1__attivaProcedimentoWide *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__attivaProcedimentoWide);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoWide ** SOAP_FMAC4 soap_in_PointerTo_ns1__attivaProcedimentoWide(struct soap *soap, const char *tag, _ns1__attivaProcedimentoWide **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__attivaProcedimentoWide **)soap_malloc(soap, sizeof(_ns1__attivaProcedimentoWide *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__attivaProcedimentoWide *)soap_instantiate__ns1__attivaProcedimentoWide(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__attivaProcedimentoWide ** p = (_ns1__attivaProcedimentoWide **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__attivaProcedimentoWide, sizeof(_ns1__attivaProcedimentoWide), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__attivaProcedimentoWide(struct soap *soap, _ns1__attivaProcedimentoWide *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__attivaProcedimentoWide);
	if (soap_out_PointerTo_ns1__attivaProcedimentoWide(soap, tag?tag:"ns1:attivaProcedimentoWide", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__attivaProcedimentoWide ** SOAP_FMAC4 soap_get_PointerTo_ns1__attivaProcedimentoWide(struct soap *soap, _ns1__attivaProcedimentoWide **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__attivaProcedimentoWide(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__attivaProcedimentoResponse(struct soap *soap, _ns1__attivaProcedimentoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__attivaProcedimentoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__attivaProcedimentoResponse(struct soap *soap, const char *tag, int id, _ns1__attivaProcedimentoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__attivaProcedimentoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__attivaProcedimentoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__attivaProcedimentoResponse(struct soap *soap, const char *tag, _ns1__attivaProcedimentoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__attivaProcedimentoResponse **)soap_malloc(soap, sizeof(_ns1__attivaProcedimentoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__attivaProcedimentoResponse *)soap_instantiate__ns1__attivaProcedimentoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__attivaProcedimentoResponse ** p = (_ns1__attivaProcedimentoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__attivaProcedimentoResponse, sizeof(_ns1__attivaProcedimentoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__attivaProcedimentoResponse(struct soap *soap, _ns1__attivaProcedimentoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__attivaProcedimentoResponse);
	if (soap_out_PointerTo_ns1__attivaProcedimentoResponse(soap, tag?tag:"ns1:attivaProcedimentoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__attivaProcedimentoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__attivaProcedimentoResponse(struct soap *soap, _ns1__attivaProcedimentoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__attivaProcedimentoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__attivaProcedimento(struct soap *soap, _ns1__attivaProcedimento *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__attivaProcedimento))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__attivaProcedimento(struct soap *soap, const char *tag, int id, _ns1__attivaProcedimento *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__attivaProcedimento);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__attivaProcedimento ** SOAP_FMAC4 soap_in_PointerTo_ns1__attivaProcedimento(struct soap *soap, const char *tag, _ns1__attivaProcedimento **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__attivaProcedimento **)soap_malloc(soap, sizeof(_ns1__attivaProcedimento *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__attivaProcedimento *)soap_instantiate__ns1__attivaProcedimento(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__attivaProcedimento ** p = (_ns1__attivaProcedimento **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__attivaProcedimento, sizeof(_ns1__attivaProcedimento), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__attivaProcedimento(struct soap *soap, _ns1__attivaProcedimento *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__attivaProcedimento);
	if (soap_out_PointerTo_ns1__attivaProcedimento(soap, tag?tag:"ns1:attivaProcedimento", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__attivaProcedimento ** SOAP_FMAC4 soap_get_PointerTo_ns1__attivaProcedimento(struct soap *soap, _ns1__attivaProcedimento **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__attivaProcedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loginResponse(struct soap *soap, const char *tag, int id, _ns1__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__loginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__loginResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__loginResponse(struct soap *soap, const char *tag, _ns1__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__loginResponse **)soap_malloc(soap, sizeof(_ns1__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__loginResponse *)soap_instantiate__ns1__loginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__loginResponse ** p = (_ns1__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__loginResponse);
	if (soap_out_PointerTo_ns1__loginResponse(soap, tag?tag:"ns1:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__loginResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__login(struct soap *soap, _ns1__login *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__login))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__login(struct soap *soap, const char *tag, int id, _ns1__login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__login);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__login ** SOAP_FMAC4 soap_in_PointerTo_ns1__login(struct soap *soap, const char *tag, _ns1__login **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__login **)soap_malloc(soap, sizeof(_ns1__login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__login *)soap_instantiate__ns1__login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__login ** p = (_ns1__login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__login, sizeof(_ns1__login), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__login(struct soap *soap, _ns1__login *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__login);
	if (soap_out_PointerTo_ns1__login(soap, tag?tag:"ns1:login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__login ** SOAP_FMAC4 soap_get_PointerTo_ns1__login(struct soap *soap, _ns1__login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTokenResponse(struct soap *soap, _ns1__getTokenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTokenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTokenResponse(struct soap *soap, const char *tag, int id, _ns1__getTokenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTokenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getTokenResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTokenResponse(struct soap *soap, const char *tag, _ns1__getTokenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getTokenResponse **)soap_malloc(soap, sizeof(_ns1__getTokenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getTokenResponse *)soap_instantiate__ns1__getTokenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getTokenResponse ** p = (_ns1__getTokenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTokenResponse, sizeof(_ns1__getTokenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTokenResponse(struct soap *soap, _ns1__getTokenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTokenResponse);
	if (soap_out_PointerTo_ns1__getTokenResponse(soap, tag?tag:"ns1:getTokenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getTokenResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTokenResponse(struct soap *soap, _ns1__getTokenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getToken(struct soap *soap, _ns1__getToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getToken(struct soap *soap, const char *tag, int id, _ns1__getToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getToken ** SOAP_FMAC4 soap_in_PointerTo_ns1__getToken(struct soap *soap, const char *tag, _ns1__getToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getToken **)soap_malloc(soap, sizeof(_ns1__getToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getToken *)soap_instantiate__ns1__getToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getToken ** p = (_ns1__getToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getToken, sizeof(_ns1__getToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getToken(struct soap *soap, _ns1__getToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getToken);
	if (soap_out_PointerTo_ns1__getToken(soap, tag?tag:"ns1:getToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getToken ** SOAP_FMAC4 soap_get_PointerTo_ns1__getToken(struct soap *soap, _ns1__getToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EccezioneSistema(struct soap *soap, ns1__EccezioneSistema *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EccezioneSistema))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EccezioneSistema(struct soap *soap, const char *tag, int id, ns1__EccezioneSistema *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EccezioneSistema);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EccezioneSistema ** SOAP_FMAC4 soap_in_PointerTons1__EccezioneSistema(struct soap *soap, const char *tag, ns1__EccezioneSistema **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EccezioneSistema **)soap_malloc(soap, sizeof(ns1__EccezioneSistema *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EccezioneSistema *)soap_instantiate_ns1__EccezioneSistema(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__EccezioneSistema ** p = (ns1__EccezioneSistema **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EccezioneSistema, sizeof(ns1__EccezioneSistema), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EccezioneSistema(struct soap *soap, ns1__EccezioneSistema *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EccezioneSistema);
	if (soap_out_PointerTons1__EccezioneSistema(soap, tag?tag:"ns1:EccezioneSistema", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EccezioneSistema ** SOAP_FMAC4 soap_get_PointerTons1__EccezioneSistema(struct soap *soap, ns1__EccezioneSistema **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EccezioneSistema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EccezioneAutenticazione(struct soap *soap, ns1__EccezioneAutenticazione *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EccezioneAutenticazione))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EccezioneAutenticazione(struct soap *soap, const char *tag, int id, ns1__EccezioneAutenticazione *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EccezioneAutenticazione);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EccezioneAutenticazione ** SOAP_FMAC4 soap_in_PointerTons1__EccezioneAutenticazione(struct soap *soap, const char *tag, ns1__EccezioneAutenticazione **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EccezioneAutenticazione **)soap_malloc(soap, sizeof(ns1__EccezioneAutenticazione *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EccezioneAutenticazione *)soap_instantiate_ns1__EccezioneAutenticazione(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__EccezioneAutenticazione ** p = (ns1__EccezioneAutenticazione **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EccezioneAutenticazione, sizeof(ns1__EccezioneAutenticazione), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EccezioneAutenticazione(struct soap *soap, ns1__EccezioneAutenticazione *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EccezioneAutenticazione);
	if (soap_out_PointerTons1__EccezioneAutenticazione(soap, tag?tag:"ns1:EccezioneAutenticazione", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__EccezioneAutenticazione ** SOAP_FMAC4 soap_get_PointerTons1__EccezioneAutenticazione(struct soap *soap, ns1__EccezioneAutenticazione **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EccezioneAutenticazione(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfFunzione(struct soap *soap, ns1__ArrayOfFunzione *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfFunzione))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfFunzione(struct soap *soap, const char *tag, int id, ns1__ArrayOfFunzione *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfFunzione);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfFunzione ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfFunzione(struct soap *soap, const char *tag, ns1__ArrayOfFunzione **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfFunzione **)soap_malloc(soap, sizeof(ns1__ArrayOfFunzione *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfFunzione *)soap_instantiate_ns1__ArrayOfFunzione(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfFunzione ** p = (ns1__ArrayOfFunzione **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfFunzione, sizeof(ns1__ArrayOfFunzione), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfFunzione(struct soap *soap, ns1__ArrayOfFunzione *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfFunzione);
	if (soap_out_PointerTons1__ArrayOfFunzione(soap, tag?tag:"ns1:ArrayOfFunzione", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfFunzione ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfFunzione(struct soap *soap, ns1__ArrayOfFunzione **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfFunzione(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Esito(struct soap *soap, ns1__Esito *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Esito))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Esito(struct soap *soap, const char *tag, int id, ns1__Esito *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Esito);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Esito ** SOAP_FMAC4 soap_in_PointerTons1__Esito(struct soap *soap, const char *tag, ns1__Esito **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Esito **)soap_malloc(soap, sizeof(ns1__Esito *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Esito *)soap_instantiate_ns1__Esito(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Esito ** p = (ns1__Esito **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Esito, sizeof(ns1__Esito), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Esito(struct soap *soap, ns1__Esito *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Esito);
	if (soap_out_PointerTons1__Esito(soap, tag?tag:"ns1:Esito", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Esito ** SOAP_FMAC4 soap_get_PointerTons1__Esito(struct soap *soap, ns1__Esito **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Esito(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Giustificativo(struct soap *soap, ns1__Giustificativo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Giustificativo))
		soap_serialize_PointerTons1__Giustificativo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Giustificativo(struct soap *soap, const char *tag, int id, ns1__Giustificativo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Giustificativo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Giustificativo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Giustificativo *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Giustificativo(struct soap *soap, const char *tag, ns1__Giustificativo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Giustificativo ***)soap_malloc(soap, sizeof(ns1__Giustificativo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Giustificativo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Giustificativo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Giustificativo, sizeof(ns1__Giustificativo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Giustificativo(struct soap *soap, ns1__Giustificativo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Giustificativo);
	if (soap_out_PointerToPointerTons1__Giustificativo(soap, tag?tag:"ns1:Giustificativo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Giustificativo *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Giustificativo(struct soap *soap, ns1__Giustificativo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Giustificativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Giustificativo(struct soap *soap, ns1__Giustificativo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Giustificativo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Giustificativo(struct soap *soap, const char *tag, int id, ns1__Giustificativo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Giustificativo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Giustificativo ** SOAP_FMAC4 soap_in_PointerTons1__Giustificativo(struct soap *soap, const char *tag, ns1__Giustificativo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Giustificativo **)soap_malloc(soap, sizeof(ns1__Giustificativo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Giustificativo *)soap_instantiate_ns1__Giustificativo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Giustificativo ** p = (ns1__Giustificativo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Giustificativo, sizeof(ns1__Giustificativo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Giustificativo(struct soap *soap, ns1__Giustificativo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Giustificativo);
	if (soap_out_PointerTons1__Giustificativo(soap, tag?tag:"ns1:Giustificativo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Giustificativo ** SOAP_FMAC4 soap_get_PointerTons1__Giustificativo(struct soap *soap, ns1__Giustificativo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Giustificativo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Flusso(struct soap *soap, ns1__Flusso **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Flusso))
		soap_serialize_PointerTons1__Flusso(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Flusso(struct soap *soap, const char *tag, int id, ns1__Flusso **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Flusso);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Flusso(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Flusso *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Flusso(struct soap *soap, const char *tag, ns1__Flusso ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Flusso ***)soap_malloc(soap, sizeof(ns1__Flusso **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Flusso(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Flusso ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Flusso, sizeof(ns1__Flusso *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Flusso(struct soap *soap, ns1__Flusso **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Flusso);
	if (soap_out_PointerToPointerTons1__Flusso(soap, tag?tag:"ns1:Flusso", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Flusso *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Flusso(struct soap *soap, ns1__Flusso ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Flusso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Flusso(struct soap *soap, ns1__Flusso *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Flusso))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Flusso(struct soap *soap, const char *tag, int id, ns1__Flusso *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Flusso);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Flusso ** SOAP_FMAC4 soap_in_PointerTons1__Flusso(struct soap *soap, const char *tag, ns1__Flusso **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Flusso **)soap_malloc(soap, sizeof(ns1__Flusso *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Flusso *)soap_instantiate_ns1__Flusso(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Flusso ** p = (ns1__Flusso **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Flusso, sizeof(ns1__Flusso), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Flusso(struct soap *soap, ns1__Flusso *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Flusso);
	if (soap_out_PointerTons1__Flusso(soap, tag?tag:"ns1:Flusso", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Flusso ** SOAP_FMAC4 soap_get_PointerTons1__Flusso(struct soap *soap, ns1__Flusso **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Flusso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Procedimento(struct soap *soap, ns1__Procedimento *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Procedimento))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Procedimento(struct soap *soap, const char *tag, int id, ns1__Procedimento *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Procedimento);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Procedimento ** SOAP_FMAC4 soap_in_PointerTons1__Procedimento(struct soap *soap, const char *tag, ns1__Procedimento **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Procedimento **)soap_malloc(soap, sizeof(ns1__Procedimento *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Procedimento *)soap_instantiate_ns1__Procedimento(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Procedimento ** p = (ns1__Procedimento **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Procedimento, sizeof(ns1__Procedimento), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Procedimento(struct soap *soap, ns1__Procedimento *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Procedimento);
	if (soap_out_PointerTons1__Procedimento(soap, tag?tag:"ns1:Procedimento", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Procedimento ** SOAP_FMAC4 soap_get_PointerTons1__Procedimento(struct soap *soap, ns1__Procedimento **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Procedimento(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MetaDato(struct soap *soap, ns1__MetaDato **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MetaDato))
		soap_serialize_PointerTons1__MetaDato(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MetaDato(struct soap *soap, const char *tag, int id, ns1__MetaDato **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MetaDato);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MetaDato(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MetaDato *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MetaDato(struct soap *soap, const char *tag, ns1__MetaDato ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MetaDato ***)soap_malloc(soap, sizeof(ns1__MetaDato **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MetaDato(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MetaDato ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MetaDato, sizeof(ns1__MetaDato *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MetaDato(struct soap *soap, ns1__MetaDato **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MetaDato);
	if (soap_out_PointerToPointerTons1__MetaDato(soap, tag?tag:"ns1:MetaDato", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MetaDato *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MetaDato(struct soap *soap, ns1__MetaDato ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MetaDato(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MetaDato(struct soap *soap, ns1__MetaDato *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MetaDato))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MetaDato(struct soap *soap, const char *tag, int id, ns1__MetaDato *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MetaDato);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MetaDato ** SOAP_FMAC4 soap_in_PointerTons1__MetaDato(struct soap *soap, const char *tag, ns1__MetaDato **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MetaDato **)soap_malloc(soap, sizeof(ns1__MetaDato *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MetaDato *)soap_instantiate_ns1__MetaDato(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__MetaDato ** p = (ns1__MetaDato **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MetaDato, sizeof(ns1__MetaDato), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MetaDato(struct soap *soap, ns1__MetaDato *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MetaDato);
	if (soap_out_PointerTons1__MetaDato(soap, tag?tag:"ns1:MetaDato", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MetaDato ** SOAP_FMAC4 soap_get_PointerTons1__MetaDato(struct soap *soap, ns1__MetaDato **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MetaDato(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfStepCompetenza(struct soap *soap, ns1__ArrayOfStepCompetenza *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfStepCompetenza))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfStepCompetenza(struct soap *soap, const char *tag, int id, ns1__ArrayOfStepCompetenza *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfStepCompetenza);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfStepCompetenza ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfStepCompetenza(struct soap *soap, const char *tag, ns1__ArrayOfStepCompetenza **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfStepCompetenza **)soap_malloc(soap, sizeof(ns1__ArrayOfStepCompetenza *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfStepCompetenza *)soap_instantiate_ns1__ArrayOfStepCompetenza(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfStepCompetenza ** p = (ns1__ArrayOfStepCompetenza **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfStepCompetenza, sizeof(ns1__ArrayOfStepCompetenza), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfStepCompetenza(struct soap *soap, ns1__ArrayOfStepCompetenza *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfStepCompetenza);
	if (soap_out_PointerTons1__ArrayOfStepCompetenza(soap, tag?tag:"ns1:ArrayOfStepCompetenza", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfStepCompetenza ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfStepCompetenza(struct soap *soap, ns1__ArrayOfStepCompetenza **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfStepCompetenza(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfStep(struct soap *soap, ns1__ArrayOfStep *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfStep))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfStep(struct soap *soap, const char *tag, int id, ns1__ArrayOfStep *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfStep);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfStep ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfStep(struct soap *soap, const char *tag, ns1__ArrayOfStep **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfStep **)soap_malloc(soap, sizeof(ns1__ArrayOfStep *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfStep *)soap_instantiate_ns1__ArrayOfStep(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfStep ** p = (ns1__ArrayOfStep **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfStep, sizeof(ns1__ArrayOfStep), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfStep(struct soap *soap, ns1__ArrayOfStep *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfStep);
	if (soap_out_PointerTons1__ArrayOfStep(soap, tag?tag:"ns1:ArrayOfStep", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfStep ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfStep(struct soap *soap, ns1__ArrayOfStep **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfStep(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Stato(struct soap *soap, ns1__Stato *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Stato))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Stato(struct soap *soap, const char *tag, int id, ns1__Stato *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Stato);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Stato ** SOAP_FMAC4 soap_in_PointerTons1__Stato(struct soap *soap, const char *tag, ns1__Stato **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Stato **)soap_malloc(soap, sizeof(ns1__Stato *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Stato *)soap_instantiate_ns1__Stato(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Stato ** p = (ns1__Stato **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Stato, sizeof(ns1__Stato), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Stato(struct soap *soap, ns1__Stato *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Stato);
	if (soap_out_PointerTons1__Stato(soap, tag?tag:"ns1:Stato", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Stato ** SOAP_FMAC4 soap_get_PointerTons1__Stato(struct soap *soap, ns1__Stato **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Stato(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfNota(struct soap *soap, ns1__ArrayOfNota *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfNota))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfNota(struct soap *soap, const char *tag, int id, ns1__ArrayOfNota *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfNota);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfNota ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfNota(struct soap *soap, const char *tag, ns1__ArrayOfNota **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfNota **)soap_malloc(soap, sizeof(ns1__ArrayOfNota *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfNota *)soap_instantiate_ns1__ArrayOfNota(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfNota ** p = (ns1__ArrayOfNota **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfNota, sizeof(ns1__ArrayOfNota), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfNota(struct soap *soap, ns1__ArrayOfNota *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfNota);
	if (soap_out_PointerTons1__ArrayOfNota(soap, tag?tag:"ns1:ArrayOfNota", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfNota ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfNota(struct soap *soap, ns1__ArrayOfNota **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfNota(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__StepCompetenza(struct soap *soap, ns1__StepCompetenza **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__StepCompetenza))
		soap_serialize_PointerTons1__StepCompetenza(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__StepCompetenza(struct soap *soap, const char *tag, int id, ns1__StepCompetenza **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__StepCompetenza);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__StepCompetenza(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__StepCompetenza *** SOAP_FMAC4 soap_in_PointerToPointerTons1__StepCompetenza(struct soap *soap, const char *tag, ns1__StepCompetenza ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StepCompetenza ***)soap_malloc(soap, sizeof(ns1__StepCompetenza **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__StepCompetenza(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__StepCompetenza ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__StepCompetenza, sizeof(ns1__StepCompetenza *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__StepCompetenza(struct soap *soap, ns1__StepCompetenza **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__StepCompetenza);
	if (soap_out_PointerToPointerTons1__StepCompetenza(soap, tag?tag:"ns1:StepCompetenza", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StepCompetenza *** SOAP_FMAC4 soap_get_PointerToPointerTons1__StepCompetenza(struct soap *soap, ns1__StepCompetenza ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__StepCompetenza(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StepCompetenza(struct soap *soap, ns1__StepCompetenza *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StepCompetenza))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StepCompetenza(struct soap *soap, const char *tag, int id, ns1__StepCompetenza *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StepCompetenza);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StepCompetenza ** SOAP_FMAC4 soap_in_PointerTons1__StepCompetenza(struct soap *soap, const char *tag, ns1__StepCompetenza **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StepCompetenza **)soap_malloc(soap, sizeof(ns1__StepCompetenza *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StepCompetenza *)soap_instantiate_ns1__StepCompetenza(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__StepCompetenza ** p = (ns1__StepCompetenza **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StepCompetenza, sizeof(ns1__StepCompetenza), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StepCompetenza(struct soap *soap, ns1__StepCompetenza *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StepCompetenza);
	if (soap_out_PointerTons1__StepCompetenza(soap, tag?tag:"ns1:StepCompetenza", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StepCompetenza ** SOAP_FMAC4 soap_get_PointerTons1__StepCompetenza(struct soap *soap, ns1__StepCompetenza **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StepCompetenza(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Funzione(struct soap *soap, ns1__Funzione **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Funzione))
		soap_serialize_PointerTons1__Funzione(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Funzione(struct soap *soap, const char *tag, int id, ns1__Funzione **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Funzione);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Funzione(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Funzione *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Funzione(struct soap *soap, const char *tag, ns1__Funzione ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Funzione ***)soap_malloc(soap, sizeof(ns1__Funzione **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Funzione(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Funzione ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Funzione, sizeof(ns1__Funzione *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Funzione(struct soap *soap, ns1__Funzione **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Funzione);
	if (soap_out_PointerToPointerTons1__Funzione(soap, tag?tag:"ns1:Funzione", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Funzione *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Funzione(struct soap *soap, ns1__Funzione ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Funzione(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Funzione(struct soap *soap, ns1__Funzione *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Funzione))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Funzione(struct soap *soap, const char *tag, int id, ns1__Funzione *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Funzione);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Funzione ** SOAP_FMAC4 soap_in_PointerTons1__Funzione(struct soap *soap, const char *tag, ns1__Funzione **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Funzione **)soap_malloc(soap, sizeof(ns1__Funzione *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Funzione *)soap_instantiate_ns1__Funzione(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Funzione ** p = (ns1__Funzione **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Funzione, sizeof(ns1__Funzione), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Funzione(struct soap *soap, ns1__Funzione *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Funzione);
	if (soap_out_PointerTons1__Funzione(soap, tag?tag:"ns1:Funzione", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Funzione ** SOAP_FMAC4 soap_get_PointerTons1__Funzione(struct soap *soap, ns1__Funzione **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Funzione(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfAttributo(struct soap *soap, ns1__ArrayOfAttributo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfAttributo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfAttributo(struct soap *soap, const char *tag, int id, ns1__ArrayOfAttributo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfAttributo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfAttributo ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfAttributo(struct soap *soap, const char *tag, ns1__ArrayOfAttributo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfAttributo **)soap_malloc(soap, sizeof(ns1__ArrayOfAttributo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfAttributo *)soap_instantiate_ns1__ArrayOfAttributo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfAttributo ** p = (ns1__ArrayOfAttributo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfAttributo, sizeof(ns1__ArrayOfAttributo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfAttributo(struct soap *soap, ns1__ArrayOfAttributo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfAttributo);
	if (soap_out_PointerTons1__ArrayOfAttributo(soap, tag?tag:"ns1:ArrayOfAttributo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfAttributo ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfAttributo(struct soap *soap, ns1__ArrayOfAttributo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfAttributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Attributo(struct soap *soap, ns1__Attributo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Attributo))
		soap_serialize_PointerTons1__Attributo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Attributo(struct soap *soap, const char *tag, int id, ns1__Attributo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Attributo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Attributo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Attributo *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Attributo(struct soap *soap, const char *tag, ns1__Attributo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Attributo ***)soap_malloc(soap, sizeof(ns1__Attributo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Attributo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Attributo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Attributo, sizeof(ns1__Attributo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Attributo(struct soap *soap, ns1__Attributo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Attributo);
	if (soap_out_PointerToPointerTons1__Attributo(soap, tag?tag:"ns1:Attributo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Attributo *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Attributo(struct soap *soap, ns1__Attributo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Attributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Attributo(struct soap *soap, ns1__Attributo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Attributo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Attributo(struct soap *soap, const char *tag, int id, ns1__Attributo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Attributo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Attributo ** SOAP_FMAC4 soap_in_PointerTons1__Attributo(struct soap *soap, const char *tag, ns1__Attributo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Attributo **)soap_malloc(soap, sizeof(ns1__Attributo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Attributo *)soap_instantiate_ns1__Attributo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Attributo ** p = (ns1__Attributo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Attributo, sizeof(ns1__Attributo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Attributo(struct soap *soap, ns1__Attributo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Attributo);
	if (soap_out_PointerTons1__Attributo(soap, tag?tag:"ns1:Attributo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Attributo ** SOAP_FMAC4 soap_get_PointerTons1__Attributo(struct soap *soap, ns1__Attributo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Attributo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ns1__ArrayOf_USCORExsd_USCOREstring *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, ns1__ArrayOf_USCORExsd_USCOREstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ns1__ArrayOf_USCORExsd_USCOREstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOf_USCORExsd_USCOREstring **)soap_malloc(soap, sizeof(ns1__ArrayOf_USCORExsd_USCOREstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOf_USCORExsd_USCOREstring *)soap_instantiate_ns1__ArrayOf_USCORExsd_USCOREstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOf_USCORExsd_USCOREstring ** p = (ns1__ArrayOf_USCORExsd_USCOREstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOf_USCORExsd_USCOREstring, sizeof(ns1__ArrayOf_USCORExsd_USCOREstring), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ns1__ArrayOf_USCORExsd_USCOREstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOf_USCORExsd_USCOREstring);
	if (soap_out_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, tag?tag:"ns1:ArrayOf_xsd_string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ns1__ArrayOf_USCORExsd_USCOREstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Step(struct soap *soap, ns1__Step **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Step))
		soap_serialize_PointerTons1__Step(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Step(struct soap *soap, const char *tag, int id, ns1__Step **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Step);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Step(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Step *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Step(struct soap *soap, const char *tag, ns1__Step ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Step ***)soap_malloc(soap, sizeof(ns1__Step **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Step(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Step ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Step, sizeof(ns1__Step *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Step(struct soap *soap, ns1__Step **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Step);
	if (soap_out_PointerToPointerTons1__Step(soap, tag?tag:"ns1:Step", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Step *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Step(struct soap *soap, ns1__Step ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Step(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Step(struct soap *soap, ns1__Step *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Step))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Step(struct soap *soap, const char *tag, int id, ns1__Step *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Step);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Step ** SOAP_FMAC4 soap_in_PointerTons1__Step(struct soap *soap, const char *tag, ns1__Step **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Step **)soap_malloc(soap, sizeof(ns1__Step *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Step *)soap_instantiate_ns1__Step(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Step ** p = (ns1__Step **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Step, sizeof(ns1__Step), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__Step **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StepCompetenza, sizeof(ns1__StepCompetenza), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Step(struct soap *soap, ns1__Step *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Step);
	if (soap_out_PointerTons1__Step(soap, tag?tag:"ns1:Step", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Step ** SOAP_FMAC4 soap_get_PointerTons1__Step(struct soap *soap, ns1__Step **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Step(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Nota(struct soap *soap, ns1__Nota **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Nota))
		soap_serialize_PointerTons1__Nota(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Nota(struct soap *soap, const char *tag, int id, ns1__Nota **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Nota);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Nota(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Nota *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Nota(struct soap *soap, const char *tag, ns1__Nota ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Nota ***)soap_malloc(soap, sizeof(ns1__Nota **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Nota(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Nota ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Nota, sizeof(ns1__Nota *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Nota(struct soap *soap, ns1__Nota **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Nota);
	if (soap_out_PointerToPointerTons1__Nota(soap, tag?tag:"ns1:Nota", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Nota *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Nota(struct soap *soap, ns1__Nota ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Nota(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Nota(struct soap *soap, ns1__Nota *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Nota))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Nota(struct soap *soap, const char *tag, int id, ns1__Nota *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Nota);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Nota ** SOAP_FMAC4 soap_in_PointerTons1__Nota(struct soap *soap, const char *tag, ns1__Nota **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Nota **)soap_malloc(soap, sizeof(ns1__Nota *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Nota *)soap_instantiate_ns1__Nota(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Nota ** p = (ns1__Nota **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Nota, sizeof(ns1__Nota), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Nota(struct soap *soap, ns1__Nota *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Nota);
	if (soap_out_PointerTons1__Nota(soap, tag?tag:"ns1:Nota", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Nota ** SOAP_FMAC4 soap_get_PointerTons1__Nota(struct soap *soap, ns1__Nota **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Nota(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
