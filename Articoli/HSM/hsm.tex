%
% $Header: /cvsroot/Cattaneo/Articoli/HSM/hsm.tex,v 1.26 2009/09/16 10:30:18 cattaneo Exp $
%
%\documentclass{acm_proc_article-sp}
%IVAN ho aggiunto queste 3 righe, e commentato la precedente, ricommenta se ho sbagliato
\documentclass{sig-alternate}
 \pdfpagewidth=8.5truein
 \pdfpageheight=11truein

\newcommand{\Owner}{\ensuremath{\mathsf{O}}}
\newcommand{\SM}{\ensuremath{\mathsf{SM}}}
\newcommand{\User}{\ensuremath{\mathsf{U}}}
\newcommand{\Proxy}{\ensuremath{\mathsf{P}}}
\newcommand{\SC}{\ensuremath{\mathsf{SC}}}
\newcommand{\RSC}{\ensuremath{\mathsf{RSC}}}
\newcommand{\SRSC}{\ensuremath{\mathsf{SRSC}}}
\newcommand{\PRSC}{\ensuremath{\mathsf{PRSC}}}
\newcommand{\MRSC}{\ensuremath{\mathsf{MRSC}}}
\newcommand{\PSCS}{\ensuremath{\mathsf{PSCS}}}

\newenvironment{myitemize}
{\begin{list}{$\bullet$}{ \itemindent=-.663cm \listparindent=.6cm
\itemsep=0.0in
\parsep=0.0in
\topsep=0.0in
\partopsep=0.0in}}{\end{list}}

\newcounter{itemcount}
\newenvironment{myenumerate}
{\setcounter{itemcount}{0}\begin{list}
{\arabic{itemcount}.}{\usecounter{itemcount} \itemindent=0.0cm
\itemsep=0.0in
\parsep=0.0in
\topsep=0.0in
\partopsep=0.0in}}{\end{list}}

\newenvironment{mydescription}
{\setcounter{itemcount}{0}\begin{list}
{\arabic{itemcount}.}{\usecounter{itemcount} \itemindent=0.0cm
\itemsep=0.0in
\parsep=0.0in
\topsep=0.0in
\partopsep=0.0in}}{\end{list}}


\newcommand{\remove}[1]{}


\begin{document}
\title{Proxy Smart Card Systems}
\subtitle{paper identification number: SEC-114}
%
%\numberofauthors{2}
%\author{
%\alignauthor G. Cattaneo, P. Faruolo, I, Visconti\\
%   \affaddr{Dip. di Informatica ed App.}\\
%   \affaddr{University of Salerno - ITALY}\\
%   \email{\{cattaneo,pomfar,visconti\}@dia.unisa.it}
%%
%\alignauthor V.  Palazzo\\
%   \affaddr{Bit4ID, ITALY}\\
%   \email{palazzo@bi4id.it}
%}

\maketitle
\begin{abstract}
Delegation of signing and decrypting capabilities
is nowadays more and more
critical because of the established legal value of digital signatures
and of the continuous increment of the available identity-based digital
services.
In this work we put forth the notion of ``Proxy Smart Card System", a
distributed system that allows a smart card owner to delegate part of
its computations (e.g., decryptions and signatures of messages) to
remote users. 

Our contribution is three fold. 
\begin{myenumerate}
\item We first stress the problematic aspects concerning 
the use of known proxy-cryptography schemes in synergy with current standard technologies. 
This in turn motivates the need of proxy smart card systems.
\item Then we formalize the security and functional requirements of a proxy
smart card system, identifying the involved parties, the adversary model
and the usability properties.
\item Finally, we present the design and analysis of a proxy smart card
system which implements the required functionalities outperforming
the current state of the art.
\end{myenumerate}
\end{abstract}

\keywords{Smart Card, Proxy Cryptography, Network Security Appliance}

\section{Introduction}
Proxy cryptography is a widely developed research area that consists in providing cryptographic primitives that allow  a user to safely delegate part of its tasks (typically decryptions and signatures of messages) to another user. Concrete applications of proxy cryptography are nowadays becoming more and more critical. For instance digital signatures are now regulated and accepted by law in almost all countries and many entities playing crucial roles in both enterprises (e.g., CEOs) and public institutions (e.g., mayors, rectors),  have to sign a large amount of documents per day.
Moreover, it is often the case that documents have to be signed urgently, even when the signer is out of his office and unreachable.
The possibility of delegating signing privileges should therefore be extended also to {\em digital} signatures. Another major example is the increasing use of decryption features for e-mails, in order to keep private some relevant data. Again, one would like to delegate to someone else the capability of decrypting some of the emails (e.g., the ones with a specific subject) in order to reduce his own amount of work and not to stop his activities when he is disconnected from the Internet.

Unfortunately we observe a huge gap between the results provided for proxy cryptography and their use in the real world. Indeed, it is well known that results produced by cryptographers need several years to be assessed and then used by practitioners. Moreover cryptography in stand-alone is not usable, it needs to be integrated in a system with  security and privacy mechanisms that can make robust all the involved components.
Proxy cryptography is affected by such delays, and indeed, while the literature already gives several provably-secure schemes with several features and reasonable efficiency, almost nothing of it is actually used in the real world. This is probably due to several reasons, and among them there is the existence
of a barrier between the requirements of proxy cryptography (e.g., system parameters, cryptographic operations) and the currently used technologies (e.g., PKIX, smart cards). Since this barrier will very likely take long time to be removed, it is therefore urgent to provide mechanisms that allow delegation of signatures and decryptions using current standard technologies.

\subsection{Our Contribution}
In this work we study the problematic aspects of using proxy cryptography along with current standard technologies to implement delegation of
signatures and decryptions. Therefore, motivated by the world-wide spread of smart cards (\SC s), and their cryptographic operations (e.g., signatures and decryptions) for implementing various cryptographic services, we put forth the notion of a \emph{Proxy Smart Card System }(\PSCS ).
We investigate the real-world scenarios and according to them we formalize the security and functional requirements of a \PSCS,
identifying the involved parties, the adversary model and the critical usability properties. We finally present the design and analysis of a proxy smart card system based on the use of a network security appliance that outperforms the current state of the art.

Our solution is a ``ready-to-use" framework that can be easily plugged
in real-life scenarios. It does not resort to currently
unadopted features of proxy cryptography and instead uses the synergy of
existing crypto tools and security technologies to obtain a robust, easy
to configure, scalable and cheap system to delegate, under some access
control policies, signature and decryption privileges.


\section{Proxy Cryptography}

The concepts of proxy signatures and proxy encryptions were introduced respectively by Mambo et al.\cite{DBLP:conf/ccs/MamboUO96} and by Mambo and Okamoto\cite{MamboO97}.  In such schemes a player called owner \Owner\, delegates to another player, called user \User, the power to execute his own cryptographic tasks. In a proxy signature system, \User\ can sign messages on \Owner's behalf, while in a proxy encryption system he can decrypt ciphertexts encrypted under \Owner's public key. In general, in such systems, \Owner\ generates some \emph{proxy secret keys} which \User s can use to sign documents verifiable through \Owner's public key and decrypt ciphertexts encrypted under \Owner's  public key.

In literature many generalizations and extensions have been proposed in the past, such as threshold proxy signatures\cite{DBLP:journals/jss/ShaoCL07}, blind proxy signatures \cite{DBLP:conf/ism/KimC06,DBLP:conf/snpd/LiuTLZ07,DBLP:conf/csse/QinW08}, proxy signatures with warrant recovery \cite{cryptoeprint:2003:072}, nominative proxy signatures \cite{DBLP:conf/icics/ParkL01}, one-time proxy signatures \cite{DBLP:conf/cans/LuCD06}, and proxy-anonymous signatures \cite{DBLP:conf/icycs/FanZL08,DBLP:conf/scn/FuchsbauerP08,DBLP:conf/snpd/HuL07,DBLP:conf/mcam/HuLL07,DBLP:conf/iscis/Yumin06,DBLP:conf/csse/ZhouW08a}.
Originally, these building blocks were considered to be used in large enterprise scenarios, where a manager would like to delegate signature capabilities or he could delegate someone else the capabilities to decrypt some messages (e.g., e-mails) encrypted with his public key. Subsequently,  the use of such schemes has been suggested in numerous other contexts as, mobile agent environment \cite{DBLP:conf/acisp/LeeKK01}, grid computing \cite{DBLP:conf/ccs/FosterKTT98}, distributed shared object systems \cite{DBLP:conf/sec/LeiwoHHT00}, global distribution networks \cite{DBLP:conf/nca/BakkerST01}, and mobile communications \cite{DBLP:conf/icics/ParkL01}.


\subsection{Security Requirements}
According to the relevant literature, a proxy signature scheme should enjoy the following properties. 
\begin{myenumerate} 
\item {\bf Verifiability}: a verifier always accepts a proxy signature computed by a delegated honest user \User.
\item  {\bf Strong Unforgeability}: it must be computationally hard for a player that is not a delegated honest \User\ to compute a new proxy signature that is accepted by a verifier.
\item {\bf Strong Identifiability}: from a proxy signature computed by a delegated user \User, it must be possible determine efficiently the identity of \User.
\item {\bf Strong Undeniability}:
it must be computationally hard for a player that computed a proxy signature, to subsequently repudiate it.
\end{myenumerate}

A proxy encryption scheme should also enjoy the following properties. 
\begin{myenumerate}
\item {\bf Correctness}: a delegated honest user \User\ always correctly decrypts an encryption of a message under \Owner's public key; 
\item {\bf Indistinguishability}: it is computationally hard for a player that is not \Owner\ and neither a delegated honest user
\User\ to distinguish the plaintext encrypted in a ciphertext w.r.t. any other possible plaintext.
\end{myenumerate}

The above properties have been formally defined along with several variations and extensions in the related literature. Here, for lack of space and the sake of
focusing the paper on the core of our contribution, we will only consider the above informal security requirements.
\subsection{Functional Requirements}

We notice that currently no proxy-cryptography scheme seems to be concretely used in practice. Our investigations about the available schemes,
the above security requirements and the available cryptographic tools, raised the following issues.
\begin{myenumerate}
\item Proxy-cryptography schemes often use number-theoretic constructions and procedures that heavily deviate from the currently available standard technology.
Their introduction in real-life scenarios would require too effort for users to move to new/different systems.
\item Several schemes do not combine gracefully security and flexibility, indeed most of the proposed systems enjoys some given properties and can not be easily
adapted to relax some of them. For instance, in some concrete applications no \Owner\ would use a system where \User s can repudiate their proxy
signatures. Moreover, no \User s would use a system where \Owner\ could make a proxy signature on his behalf.
\item Several schemes suffer of practical limitations (e.g., an efficient revocation mechanism, mechanisms to filter the type of document that can be signed or decrypted,
tools for monitoring \User s activities).
\end{myenumerate}

Summing up, the work done so far on proxy cryptography mainly focused on the design of powerful cryptographic primitives, but unfortunately it substantially ignored the concrete functional requirements of a practical and easy to use system. In order to be more concrete about such requirements, we studied different contexts
where proxy signatures and decryptions are needed an we collected the \emph{functional requirements} (beyond the usual security requirements), that we believe
any practical proxy signature/encryption system should enjoy. We summarize those requirements in the following categories.
\begin{myenumerate}
\item {\bf Compatibility}: schemes should use standard technologies only in order to be compatible with current software application. 
\item {\bf Robustness}: schemes
should be secure and reliable.
\item {\bf Flexibility}: schemes should allow users to configure and select the appropriate features dynamically.
\item {\bf Efficiency}: schemes should satisfy some critical performance requirements.
\end{myenumerate}


\section{Design of a PSCS}

Following the security and functional requirements identified in the previous section, we designed a \PSCS , that is, a proxy smart cards system that can be used
to safely delegate signing and decrypting capabilities of a personal smart card. In our system \Owner s can allow authorized \User s to remotely access to their \SC s in order to sign and decrypt messages using their private keys. Notice that smart cards are nowadays a standard technology deployed to all citizens by means of electronic ID cards. Moreover, the use of smart cards guarantees a high level of robustness of the system, thanks to the hardness of extracting private keys (i.e. the device is considered tamper proof). Here we consider \SC s as standard PKCS\#11-compliant smart cards, where the critical operations are protected by PIN.

A central role in our \PSCS\ is the Proxy Server \Proxy, a hardware/software network security appliance equipped with smart card readers. The purpose of \Proxy\ is to allow \User s to use the signing/decrypting capabilities of \SC\ without compromising any critical information (e.g., private keys, PIN).  \Owner\ shares his \SC s by plugging them into readers connected to \Proxy, while \User s remotely interacts with \Proxy\ to use them according to the role-based access control (in short, RBAC) configured by \Owner . These interactions are implemented by \PSCS\ through a \emph{Remote PKCS\#11}, that is, a library that exposes to \User s standard PKCS\#11 functionalities while the computations are carried out on \SC s plugged in \Proxy . Using this approach, \User s can continue to use his standard applications also on \Owner 's \SC s to compute proxy signatures or to decrypt messages.

%PEO : ci serve dire che uno deve riavviare il sistema? vedi nota successiva
Making \SC s remotely available introduces the problem of filtering remote access to the \SC s. This requires the assumption that \Proxy\  is a {\sl tamper proof/evident network security appliance} designed to provide the same services of a local smart card reader through the net. Our system also includes a special player, referred to as system manager \SM, with the role of keeping the system on-line when \Owner s leave their smart cards in \Proxy\ and the system has to be secure when off-line and functional also over reboots. Notice that when \Owner s prefer to have the system on-line only when they are physically close to \Proxy, then \SM\ does not need to exist.


\subsection{Remote Smart Card}
The smart cards that \Proxy\ makes available to \User s do not necessarily correspond to the smart cards plugged in card readers. Indeed, in our system \Owner s have the possibility to configure \SC s in different operating modes giving to \User s a virtual view of the \SC s available. In detail, \Owner s can define the \emph{Remote Smart Card} (\RSC) as \emph{Single} (\SRSC) or \emph{Parallel} (\PRSC). In the former case, a \RSC\ corresponds exactly to a real \SC\ while in the latter case several \SC s, offering the same objects, will appear to \User s as a single \RSC . A request on a \PRSC\ can be executed indifferently by any \SC\ linked to it. 
The above mechanism makes the system more efficient, indeed, a \PRSC\ allows one to parallelize the load of requests across its \SC s.
%PEO: forse dobbiamo dire che vuol dire "diverse SCs con gli stessi oggetti" e come si puo fare ad averle. Se stessi oggetti intendiamo stesse private key. Se le key sono diverse va bene per le firma ma ovviamente no per la decrypt 
%IVAN aggiungo questa frase
Obviously \SC s with different keys can still be used for delegated signatures, but instead only one of them can be used for decrypting a message.
The above mechanism makes the system more efficient, indeed, a \PRSC\ allows one to parallelize the load of requests across its \SC s.


\subsection{Set up of the System}
All \User s and \Owner s must enroll the system by registering their public keys. \Owner\ plugs his \SC s into the smart card readers connected to \Proxy. 
%PEO: con la gestione dei pin non ? necessario inseire niente al reboot. Senza invece SM deve mettere la sua private key per decifrare la tavola dei pin ... O non da niente a SM%
%IVAN: peo, ci vuole la key di SM perch? altrimenti un USER corrotto che accede al disco usa il suo virtual pin per prendersi il pin reale, si prende la carta e la frittata e' fatta. Il ruolo di SM e' duplice: far si che USER fallisce in questo attacco, ed inoltre tenere il sistema on-line quando capita un reboot e O e' assente
During the boot of \Proxy\ a special user referred to as \SM\ will activate the use of smart cards in \Proxy\ by 
entering a secret key received by \Owner. This will be describe more precisely later when we will discuss PIN management issues.
Through a remote administration web interface \Owner\ sets the configuration of his \RSC s and defines the related access policies for the delegated \User s.
An authorized \User\ for a given \RSC, receives a special PIN that does not correspond to the
real \SC 's PIN, but instead is a \emph{virtual PIN} that allows him to access  that \RSC. We discuss more in details in the next section the problematic issues concerning  PIN management, and we the technical motivation of our more elaborated solution. 
\Owner s can revoke the delegated capabilities to each
\User\ in any moment by simply updating the access control policies. Such updates have immediate effects, indeed a revoked \User\ will not be able to invoke any further service on \Proxy . The past signatures will remain valid. The system allows \Owner s to authorize the delegation only for a given time period and/or on specific documents (e.g., decryption only of e-mails with a given subject). Moreover, \Owner\ can decide if the proxy signatures will be with or without warranty (in the former case, the signature will contain also a warning about the delegation). 

\subsection{Proxy Signatures/Decryptions} 
\User\ first gets access to \RSC\ by means of a strong authorization mechanism (i.e. TLS client authentication through digital certificates), then can use standard applications to sign or decrypt documents through \Owner 's \SC . According to his privileges the application will enumerate all the \RSC s available as PKCS\#11 slots. Selected a \RSC , invokes the sign/decrypt operation, providing the virtual PIN when asked. The client component will sign the request with \User 's private key and will sent it to the server component. The request will be logged by \Proxy, so that it cannot be repudiated anymore. If the PIN is correct and \User\ has the required privileges, the operation is executed by the related \SC\ and the result is sent back to \User . The system will dispatch the requests on a \PRSC\ to the first available \SC\ linked to that \PRSC\ through a Round Robin scheme that is able to balance the load of requests. Since the sign/decrypt functions are long term operations, this mechanism radically improves system performance linearly scaling with the number of \SC s configured for the \PRSC . The system allows \Owner s access to logs database in order to check completely the activity of their delegates.


\subsection{Security Model}
Given the critical use of smart cards in real world scenarios, a security model is required in order to show that a proposal is resilient to attacks mounted by malicious players. First of all, we follow the standard approach that assumes that an adversary has complete control over the communication channel. This includes the capability of reading and updating all messages that cross the network, of delaying the delivering of messages, and so on.

We assume that \Proxy\ is a trusted played, this means that when it is active it follows the prescribed procedures and his behavior can not be compromised. This assumption is both 1) necessary, and 2) achievable in practice.
Indeed, in case \Proxy\ is under the control of an adversary, since \SC s are plugged into its readers, and remotely accessed through its software, the adversary would obtain the PINs of the \SC s and thus could also ask them non-authorized services (e.g., signatures, decryptions). Notice that while it is known how to design protocols that are secure even in presence of such adversaries, the known solutions require that honest players (in this case \SC s and honest \User s) perform computations that go much beyond the simple PKCS\#11 interface that is currently available in standard smart cards.

The above assumption about \Proxy\ is also achievable in practice since the hardware infrastructure of \Proxy\ can be placed into a special hard to access area (basically implementing a tamper evident mechanism) and moreover his software could be placed in ROM (e.g., a CD physically hardwired in the device with a tamper evident mechanism). There must be instead a read-write (RW, in short) memory that will contain for instance log files and the RBAC policy files. We do not assume special requirements about such an RW memory, indeed all such files remain valid and used by \Proxy\ as long as there is a valid message authentication code associated
to them. Moreover, erasing such data or trying to restore previous data will have no effect since \Proxy\ is assumed to periodically send through S/MIME~\cite{smime} encrypted and signed backups of those files to the addresses associated to \Owner s.

We assume that {\em qualified} \User s are honest while other \User s can be corrupted. The distinction between such two categories depends on the RBAC policies configured for each smart card. \User s that can access to services provided by some \SC s are assumed to be honest for those \SC s and dishonest for the remaining \SC s. Notice that since RBAC policies are dynamic, the set of qualified users is dynamic as well, and thus a user can be considered honest only temporarily (therefore one can not simply assume that the owner of a \SC\ gives the PIN to qualified \User s).
All honestly produced \SC s are assumed to be incorruptible, instead an adversary can produce some non-legitimate \SC s that can be plugged into the readers of \Proxy.
Finally, we assume that each \Owner\ is honest only with respect to his \SC s.

\subsection{Pin Management}
A major requirement for the design of a proxy smart-card system is the transparent use of remote smart cards as they were local. Indeed, clients would like to recycle their applications that access to local smart cards so that they can also be used to access remote smart cards connected to the proxy smart-card system. Notice that access to
a smart card is possible through a log on procedure where a personal identification number (PIN) has to be provided by the user and sent to the smart card. The need of recycling standard applications implies that one can not simply assume that qualified users are identified by the system through passwords. This restriction is enforced by recent laws that mandatory require the use of PINs for accessing smart cards.
Moreover, after  a prescribed number of PIN log on failures a PUK is needed to restore access to the smart card.

The above problem could in general be solved by the following trivial solution: the PIN of the smart card is communicated to all users that have sufficient privileges to access the smart card. This solution however does not satisfy the flexibility requirement of a proxy smart-card system since user's privileges are in general dynamic and thus removing a user from the system would require the generation of new PINs that then should be distributed to all qualified users. This is clearly unacceptable in systems with many users and dynamic assignment of privileges. We have therefore developed a more sophisticated system.

\subsubsection{Virtual PINs}
The failure of the trivial solution discussed above implies that the PIN on the client's side must be different from the real PIN that allows one to succeed in the log on procedure with the smart card. Indeed, remember that even though \Proxy\ uses RBAC policies, a corrupted \User\ can try to remove a card from the system while it is off-line and then knowledge
of the PIN would allow him to obtain illegitimate signatures. It is therefore fundamental to establish a virtual PIN system where users know some virtual PINs that can be translated into real PINs by the proxy smart-card system.

In this direction one can consider the following simple but wrong solution. The RBAC policy is encoded through a table where each \User\ has associated a mapping
between virtual PIN and real PIN. Therefore, upon receiving a remote log on request with a given virtual PIN, \Proxy\  simply accesses the table and translate the virtual PIN to a real PIN to be used for the log on procedure with the smart card. This procedure would match the flexibility requirement of the system. However, it still includes a security drawback that we want to exclude from of architecture. Indeed, the above table should be stored somewhere in the permanent memory of \Proxy\ and would include the real PIN.
A physical attack to \Proxy\ when it is off-line, with the aim of reading the content of this disk, would give to the adversary knowledge of both virtual and real PINs. The problem is that it can directly use the smart cards through the real PINs in case he will be able to physically extract them from \Proxy.

\subsubsection{Encrypted Virtual PINs}
The need of protecting the system from the above attack implies the use of an encryption mechanism so the a virtual PIN sent by the client is then translated into a real
PIN without storing such PINs in the permanent memory of \Proxy. \Proxy\ could therefore store the above table in an encrypted format. The decryption key would
usually be in the memory of \Proxy\ and could be loaded either automatically during the boot or by an activation procedure where the key is inserted manually. Notice that the former case requires the secret key to be stored on the permanent memory and thus does not prevent the physical attack discussed above. The latter approach instead could be managed by using the special player \SM\ previously mentioned in the description of the our system. However, notice that in case \SM\ is
corrupt still the table with all real pins would be exposed, cards can be removed and used somewhere else. We have therefore developed a more
advanced scheme that goes beyond such limitations.

\subsubsection{PIN Encryption Scheme.}
We show now our solution for managing the translation of a virtual PIN into a real PIN without significantly
decreasing the security and the flexibility of the system, thus improving the
benefits of the mechanisms discussed above.

We use the virtual PIN as a key for the symmetric encryption of the real PIN. Therefore, when a new virtual PIN is generated and associated to a real PIN, \Proxy\ will be updated by adding a new entry in an access control table and it will contain an encryption of the real PIN computed by means of the virtual PIN as key.

When the user accesses remotely the smart card, he has to send the virtual PIN that then will be used by \Proxy\ to decrypt the corresponding entry in the RBAC table and to perform the log on procedure on the smart card. Notice that using this approach we can still have flexibility and at the same time no key or PIN is stored unencrypted in the permanent memory of \Proxy\ thus preventing the above physical attacks when \Proxy\ is off-line.

However, there still use a subtle security problem. Indeed, since PINs are elements of a relatively small space (e.g., $10^8$) one could mount a brute force attack against the access control table in order to decrypt the real PIN. Indeed, using a standard encryption scheme as AES256, the decryption under a key $k$
of a 256-bit ciphertext will result in a 256-bit  plaintext that very likely will be greater than $10^8$ when $k$ is the wrong key and instead will be less than $10^8$ when $k$
is the correct key. Therefore, with a feasible (just $10^8$ iterations) brute force attack, one can still obtain the real PIN (assuming that by physically
accessing \Proxy the adversary also obtains the table).

It is therefore critical that each ciphertext when decrypted with any possible virtual PIN, still produces a well-formed PIN that the adversary should try in the log on procedure. In this case, after $3$ wrong trials the smart card becomes unusable and the adversary is stuck.

We therefore propose the following scheme: the virtual PIN is first extended to $256$-bit long string by means of SHA256. Then the real PIN is extended to a $256$ bit by randomly
padding the remaining $(256-27)$ bits ($10^8$ requires 27 bits). Then AES256 is computed using the extended virtual PIN as key and the extended real PIN as message.
In this case, a brute force attack always produces $256$-bit long plaintexts that can be reduced considering the last $27$ bits to a candidate PIN. Notice that if the first bit of those $27$ bits is
$0$, then the resulting number is always a valid candidate PIN. Instead, if the first bit is $1$ the value can go beyond $10^8$, and in this case the adversary could discard
this value. Summing up, trying the $10^8$ possible virtual PINs, the adversary will have at least $2^{26}$ candidate PINs, which is currently considered a satisfying
space with respect to the only $3$ chances that the adversary could have.

Finally, we remark that still in case \User\ knows a virtual PIN and has physical access to \Proxy, it can obtain the real PIN. Therefore, we suggest to use
the above PIN encryption scheme along with the use of a special activation key provided by \SM\, in order to decrypt the table. More formally, each entry
of the table will be encrypted twice. The two keys for decrypting it are the key given by \SM\ during the boot of \Proxy\ (we stress again that \SM\ can be removed when the system does
not need to be on-line when \Owner s are away) and the virtual PIN. As long as there is no coalition between \SM\ and \User\ the system will result
to be secure. We therefore require \Owner s not to fail twice giving privileges (i.e., activation keys to \SM, delegation of \SC s to \User s) to corrupted players.

\subsection{Implementation Details}
In this section we illustrate the main implementation
details of our \PSCS. First of
all we implemented our \PSCS\ using a Client/Server schema, between
the PKCS\#11 local component (on client side) and the PKCS\#11 engine (on server side). The
first one exposes a standard PKCS\#11 interface to \User\ local
application, but when the applications invoke its functions, the
module remotely calls the corresponding engine function on \Proxy . Invocations are encapsulated in a proprietary format
and sent using the HTTP protocol through a secure IP channel (HTTPS)
with mutual authentication based on the exchange of X.509 certificates \cite{PKIX}. The
server engine forwards the requests to the plugged \SC s and returning to
the client the results. In the standard PKCS\#11 interface some
functions must be coded by the library and some others must be
executed natively by the \SC . Some computations (e.g., 
AES symmetric encryptions,  cryptographic hashing), 
are executed locally by the client module while others (e.g.
signatures, decryptions) by \SC\ on \Proxy\ through the engine
component. We stress that this mechanism is transparent to \User s
and requires only the availability of \User's authentication capabilities 
in the standard PKIX \cite{PKIX} setting.

On the server side, to speed up the prototype realization we used a
standard high level application server called Twisted \cite{twisted}
coding all the \Proxy\  modules using the language python while the client component has been written in C
language. Free BSD 4.4 has been chosen as the host operating system
including some security features for certificate management and the
secure network layer.


As showed in Figure \ref{fig:architecture}, the overall architecture of \PSCS\ is
set up by 4  modules: \emph{Policy Manager}, \emph{Log Service},
\emph{RequestHandler} and the \emph{CardHandler}. The functions
implemented by the first two are straightforward: the former module
implements the RBAC policies management while the
latter module provides high level API to log all system activities
along with the certification of the log file integrity.

\begin{figure}[hb]
%%% questa e' ok per Windows
%%\centerline{\includegraphics[bb = 0 0 4197 2131,width=8.5truecm]{Architettura.jpg}}
%%% la prossima e' ok per mac
\centerline{\includegraphics[width=8.5truecm]{Untitled.png}}
\caption{PSCS architecture} \label{fig:architecture}
\end{figure} 



The module \emph{RequestHandler} listens to \User 's requests.  Its
main tasks consists parsing the requests, verifying \User 's
credentials according to the RBAC policies and, maintaining the
sessions information for each \User s. RequestHandler maps the requests trough a
dictionary with the running configuration that is the list of the
available objects, updating the structure each time a new \SC\ is
inserted or removed.  For each physical card reader available to the \PSCS\ there is an
instance of the module \emph{CardHandler}, which runs as a separate
process, that handles the \SC . It monitors the \SC\ status changes (insertion,
removal or failure), invokes on it a request at once and returns to the requester the result.
Whenever during the processing phase an error is
raised, the error messages is forwarded to the client
PKCS\#11 module in order to let the application to report the error message.  The interactions between the RequestHandler and the various CardHandler is accomplished through a set of queues, one for each \RSC . The RequestHandler puts on the target queue the verified requests. Each CardHandler picks up a request in front of a queue in order to be performed. From a \SRSC\ queue only the CardHandler that handles the related \SC\ can take the requests. From a \PRSC\ queue all CardHandler that manage the \SC s linked to the \PSCS\ can pick up requests. The CardHandler modules access to this queue through a Round Robin schema.



\section{Analysis of PSCS}

We now show that the above system satisfies all the security and functional requirements discussed in previous Sections.

\subsection{Security Requirements}
We start with the security requirements. We stress that we will discuss informally the security of our system, since the scope of this work
is to show that proxy smart card systems can be concretely used in realistic scenarios. For lack of space we can not also include formal definitions and proofs.

\subsubsection{Verifiability}  In our system a signature is generated by using the private key of \Owner. Therefore the canonical verification procedure of the
signature scheme can successfully assess the validity of the signature.

\subsubsection{Strong Unforgeability} Assume that an unauthorized signature is obtained by an adversary. Notice that since the signing keys are in the tamper proof area of the smart card, such a signature must have been produced by the smart card after a successful log on procedure, which requires the use of a correct PIN. Since in our security model we assume that \Proxy\ can not be compromised, we can therefore distinguish two cases: 1) the adversary has obtained the signature accessing the system remotely while it is on-line; 2) the adversary has obtained the signature while the system was off-line.
The former case, has negligible probability to happen since \Proxy\ follows the RBAC policies and therefore gives back a signature computed by \SC\ only if \User\ has the corresponding rights. Therefore it must be the case that the adversary impersonated \User. This however can not happen as long as we \User\ has not been corrupted and thus his smart card and computing resources have not been violated. The use of TLS and PKIX prevents further impersonations. The case in which \User\ has been corrupted instead does not correspond to an unauthorized signature, since \User\ becomes the adversary and thus it obtained a legitimate signature.
The latter case, consists instead in physically attacking \Proxy. Notice that the adversary can extract \SC\ from the reader but still he needs a valid PIN to access to it. By also tampering \Proxy\ he can read the RBAC database and obtain the encryptions of the PIN but still he is not able to decrypt them, since virtual PINs are needed for the decryption. Obtaining a virtual PIN requires either hacking the TLS protocol (since virtual PIN are always sent by a legitimate \User\ to \Proxy\ in a TLS-encrypted channel) and corrupting \SM\ or corrupting \User\ and \SM. While the former is assumed to be infeasible by the security of the TLS protocol, the latter is assumed to be impossible in our security model as a coalition of \SM\ and \User\ is assumed not to be possible. We stress that such a coalition does not make any sense when \SM\ corresponds to \Owner, moreover when \SM\ is another entity, his power has been directly obtained from \Owner\ to make services available when \Owner\ has not
access to \Proxy.

\subsubsection{Strong Undeniability} In our system when \User\ requests the signature of a message $m$ under \Owner's public key, it has to sign such a request using his personal smart card, and such a signature is sent to \Proxy\ which then verifies it before sending a signature request for $m$ to the smart card corresponding to \Owner. It turns out therefore that as long as \User' local computing system is not under attack, all his signature request stored by \Proxy\ correspond actually to request sent by \User.

\subsubsection{Strong Identifiability} The actual message that is signed by \SC\ is a pair {\tt msg}$=(m,id)$ where $m$ is the message requested by \User\ and $id$ is the identity of \User\ that has also been logged in \Proxy\ along with the signature request. Therefore each signed message uniquely and securely identifies \User.

\subsubsection{Correctness} The correctness of an encryption scheme is immediately translated in the correctness of the proxy system since \SC\ will be able to decrypt a message upon receiving a request of \Proxy\ on behalf of a legitimate \User.

\subsubsection{Indistinguishability} The semantic security of the underlying encryption scheme ensures that an encrypted message does not disclose any information about the plaintext as long as the decryption key is not available to an adversary. However, the decryption is stored in the tamper proof area of the smart card, therefore in order to be able to decrypt message without a legitimate authorization, an adversary has to violate either the RBAC policies while the system is on-line or should physically attack the system while it is off-line. The analysis here continue almost verbatim as we have already discussed for strong unforgeability.
Further details are therefore omitted.

\subsection{Usability and Performance Analysis}
We now discuss the functional requirements.

\subsubsection{Compatibility} Compatibility with standard software is a critical requirements to obtain a usable system. Therefore \Proxy\ must be addressed as a local device (\SC\ reader) through a special PKCS\#11 driver (library) which routes the application requests to the remote appliance through the local network connection. This should be transparent to any application designed to operate through PKCS\#11 functions. No change or rebuild should be necessary to applications when using the appliance services. This is necessary to preserve the certification process of the applications. Moreover, signatures produced by \User s are verifiable with standard procedures since they are actually computed by \SC. Notice that source codes of such application are not commonly available, therefore
we do not modify anything else including the user interface, (e.g., the PIN management) thus preserving the laws compliance of the application. More in details, to enforce legal compliance, especially with respect to the PIN management, the appliance should exhibit the same behavior of a local \SC\ blocking the card (service for the user) after $3$ PIN log on failures.

\subsubsection{Robustness}
Beyond what we have discussed so far there are several other requirements depending on the fact that the legitimate owner leaves her \SC\  connected to the network appliance, to keep alive the proxy system. Indeed both honest and malicious \User s could try to use the system, basically obtaining digital signatures/decryptions of documents/ciphertexts. Therefore, it is necessary to enforce strong authentication and  tracking mechanisms to identify users, to manage privileges and to meaningfully log all the operations performed by \Proxy\ with each \SC\ for a given \User.
As for any network device, \Proxy\ could be attacked (even by authorized \User s), and this should not be turned in a general DoS attack but only the specific \SC\
should stop its activities for that  user.
Since \SC s  are remote with respect to \User s, hardware failures should be considered with more attention. An operation on a \SC \ object occasionally can fail due to several reasons (e.g., electrical failures, unusual temperature), but that \SC \ could become again available. Therefore the network appliance should enforce a stronger policy on the failure management, introducing a retry mechanism with exponential delay up to some bound.

\subsubsection{Flexibility}
Through the RBAC policies \Owner s can allow access to their \SC s in very different ways, such as, for a fixed time, only in the office time or according to the type of document to be signed/decrypted. The system allows \Owner\ to configure the proxy signature service with or without the warranty about the identity of  \User . Moreover,  adding a new \SC\  makes automatically available the resource to all clients even if they are already connected to the appliance, and no reboot is required. On the other hand, since client applications are stateless, removing a card at run time is an issue that we considered. In any case before unmounting a card the related queue must be empty. Finally the network appliance is provided with an html-based management module which enables the administrator to manage the available \SC s, the various configurations, and to perform all the basic administrative tasks (e.g., upgrade, new module installation, power up, shutdown).


\subsubsection{Efficiency}
The system was designed to manage elevate rate of requests. Obliviously the main bottleneck is represented by \SC\ operations that can be slow with respect to the request handling. In order to improve the system performance \Owner s can use several \SC s in the \PRSC\  configuration so that several requests can be served in parallel. The system adopt a Round Robin scheme to dispatch the requests to the first available reader, providing the maximum concurrency degree with respect to the number of \SC\  available.


\section{Conclusion}
We have conducted several performance measurements with different use cases. In all of them, our system resulted sufficiently practical, flexible, efficient and secure
as no other system currently available in the literature. Given that our system is also cheap to set up and easy to install, we expect that our work will also give
a chance for further extensions and improvements, thus generating follow up research on this topic.




\bibliographystyle{acm}
%\bibliography{hsm}

\begin{thebibliography}{10}


\bibitem{cryptoeprint:2003:072}
{\sc Awasthi, A.~K., and Lal, S.}
\newblock Proxy blind signature scheme.
\newblock Cryptology ePrint Archive, Report 2003/072, 2003.
\newblock http://eprint.iacr.org/.

\bibitem{DBLP:conf/nca/BakkerST01}
{\sc Bakker, A., van Steen, M., and Tanenbaum, A.~S.}
\newblock A law-abiding peer-to-peer network for free-software distribution.
\newblock In {\em NCA\/} (2001), IEEE Computer Society, pp.~60--67.

\bibitem{DBLP:conf/icycs/FanZL08}
{\sc Fan, C., Zhou, S., and Li, F.}
\newblock Deniable proxy-anonymous signatures.
\newblock In {\em ICYCS\/} (2008), IEEE Computer Society, pp.~2131--2136.

\bibitem{DBLP:conf/ccs/FosterKTT98}
{\sc Foster, I.~T., Kesselman, C., Tsudik, G., and Tuecke, S.}
\newblock A security architecture for computational grids.
\newblock In {\em ACM Conference on Computer and Communications Security\/}
(1998), pp.~83--92.

\bibitem{DBLP:conf/scn/FuchsbauerP08}
{\sc Fuchsbauer, G., and Pointcheval, D.}
\newblock Anonymous proxy signatures.
\newblock In {\em SCN\/} (2008), pp.~201--217.

\bibitem{PKIX}
R.~Housley, W.~Polk, W.~Ford, and D.~Solo.
\newblock Internet {X509} public key infrastructure: {Certificate} and
{Certificate Revocation List (CRL)} {P}rofile.
\newblock Network Working Group, RFC 3280, April 2002.

\bibitem{DBLP:conf/snpd/HuL07}
{\sc Hu, C., and Li, D.}
\newblock A new type of proxy ring signature scheme with revocable anonymity.
\newblock In {\em SNPD (1)\/} (2007), pp.~866--868.

\bibitem{DBLP:conf/mcam/HuLL07}
{\sc Hu, C., Liu, P., and Li, D.}
\newblock A new type of proxy ring signature scheme with revocable anonymity
and no info leaked.
\newblock In {\em MCAM\/} (2007), pp.~262--266.

\bibitem{DBLP:conf/ism/KimC06}
{\sc Kim, Y.~S., and Chang, J.~H.}
\newblock Provably secure proxy blind signature scheme.
\newblock In {\em ISM\/} (2006), IEEE Computer Society, pp.~998--1003.

\bibitem{DBLP:conf/acisp/LeeKK01}
{\sc Lee, B., Kim, H., and Kim, K.}
\newblock Secure mobile agent using strong non-designated proxy signature.
\newblock In {\em ACISP\/} (2001), V.~Varadharajan and Y.~Mu, Eds., vol.~2119
of {\em Lecture Notes in Computer Science}, Springer, p.~474.

\bibitem{DBLP:conf/sec/LeiwoHHT00}
{\sc Leiwo, J., H{\"a}nle, C., Homburg, P., and Tanenbaum, A.~S.}
\newblock Disallowing unauthorized state changes of distributed shared objects.
\newblock In {\em SEC\/} (2000), S.~Qing and J.~H.~P. Eloff, Eds., vol.~175 of
{\em IFIP Conference Proceedings}, Kluwer, pp.~381--390.

\bibitem{DBLP:conf/snpd/LiuTLZ07}
{\sc Liu, W., Tong, F., Luo, Y., and Zhang, F.}
\newblock A proxy blind signature scheme based on elliptic curve with proxy
revocation.
\newblock In {\em SNPD (1)\/} (2007), pp.~99--104.

\bibitem{DBLP:conf/cans/LuCD06}
{\sc Lu, R., Cao, Z., and Dong, X.}
\newblock Efficient id-based one-time proxy signature and its application in
e-cheque.
\newblock In {\em CANS\/} (2006), D.~Pointcheval, Y.~Mu, and K.~Chen, Eds.,
vol.~4301 of {\em Lecture Notes in Computer Science}, Springer, pp.~153--167.

\bibitem{MamboO97}
{\sc Mambo, M., and Okamoto, E.}
\newblock Proxy cryptosystem: delegation of the power to decrypt ciphertexts.
\newblock In {\em IEICE Trans. Fundamentals E80-A(1)\/} (1997), pp.~54--63.

\bibitem{DBLP:conf/ccs/MamboUO96}
{\sc Mambo, M., Usuda, K., and Okamoto, E.}
\newblock Proxy signatures for delegating signing operation.
\newblock In {\em ACM Conference on Computer and Communications Security\/}
(1996), pp.~48--57.

\bibitem{DBLP:conf/icics/ParkL01}
{\sc Park, H.~U., and Lee, I.~Y.}
\newblock A digital nominative proxy signature scheme for mobile communication.
\newblock In {\em ICICS\/} (2001), S.~Qing, T.~Okamoto, and J.~Zhou, Eds.,
vol.~2229 of {\em Lecture Notes in Computer Science}, Springer, pp.~451--455.

\bibitem{DBLP:conf/csse/QinW08}
{\sc Qin, Y., and Wu, X.}
\newblock Cryptanalysis and improvement of two blind proxy signature schemes.
\newblock In {\em CSSE (3)\/} (2008), pp.~762--765.

\bibitem{smime}
{\sc S/MIME RFC}.
\newblock http://www.ietf.org/rfc/rfc2633.txt?number=2633

\bibitem{DBLP:journals/jss/ShaoCL07}
{\sc Shao, J., Cao, Z., and Lu, R.}
\newblock Improvement of yang et al.'s threshold proxy signature scheme.
\newblock {\em Journal of Systems and Software 80}, 2 (2007), 172--177.


\bibitem{twisted}
{\sc Twisted Matrix Lab}.
\newblock http://twistedmatrix.com

\bibitem{DBLP:conf/iscis/Yumin06}
{\sc Yumin, Y.}
\newblock A threshold proxy signature scheme with nonrepudiation and anonymity.
\newblock In {\em ISCIS\/} (2006), vol.~4263 of {\em Lecture Notes in Computer
Science}, Springer, pp.~1002--1010.



\bibitem{DBLP:conf/csse/ZhouW08a}
{\sc Zhou, X., and Wei, P.}
\newblock Anonymous proxy authorization signature scheme with forward security.
\newblock In {\em CSSE (3)\/} (2008), pp.~872--875.

\end{thebibliography}
\end{document}
